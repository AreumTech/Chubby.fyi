// Code generated by generate-go-types.js - DO NOT EDIT
// Source: schemas/simulator-interface.yaml

package engine

import (
	"encoding/json"
	"fmt"
	"math"
)

// =============================================================================
// BRANDED TYPES - Prevent unit confusion at runtime
// =============================================================================

// MonthlyAmount represents a dollar amount per month
type MonthlyAmount float64

// Validate ensures the amount is finite and reasonable
func (m MonthlyAmount) Validate() error {
	if math.IsNaN(float64(m)) || math.IsInf(float64(m), 0) {
		return fmt.Errorf("invalid monthly amount: %v", float64(m))
	}
	if m < -1000000 || m > 100000000 {
		return fmt.Errorf("unrealistic monthly amount: %v", float64(m))
	}
	return nil
}

func (m MonthlyAmount) ToFloat64() float64 {
	return float64(m)
}

// MonthOffset represents months from simulation start
type MonthOffset int

// Validate ensures the offset is non-negative and reasonable
func (m MonthOffset) Validate() error {
	if m < 0 {
		return fmt.Errorf("invalid month offset: %d (must be non-negative)", int(m))
	}
	if m > 1200 { // 100 years max
		return fmt.Errorf("unrealistic month offset: %d (max 1200)", int(m))
	}
	return nil
}

func (m MonthOffset) ToInt() int {
	return int(m)
}

// Percentage represents a rate as decimal (0.05 = 5%)
type Percentage float64

// Validate ensures the percentage is reasonable
func (p Percentage) Validate() error {
	if math.IsNaN(float64(p)) || math.IsInf(float64(p), 0) {
		return fmt.Errorf("invalid percentage: %v", float64(p))
	}
	if p < -1.0 || p > 10.0 {
		return fmt.Errorf("unrealistic percentage: %v (%v%%)", float64(p), float64(p)*100)
	}
	return nil
}

func (p Percentage) ToFloat64() float64 {
	return float64(p)
}

// ToPercentString formats as percentage string
func (p Percentage) ToPercentString() string {
	return fmt.Sprintf("%.2f%%", float64(p)*100)
}

// StandardAccountType represents account classification
type StandardAccountType string

const (
	AccountTypeCash        StandardAccountType = "cash"     // Legacy - being phased out
	AccountTypeChecking    StandardAccountType = "checking" // Low-yield checking account
	AccountTypeSavings     StandardAccountType = "savings"  // Higher-yield savings account
	AccountTypeTaxable     StandardAccountType = "taxable"
	AccountTypeTaxDeferred StandardAccountType = "tax_deferred"
	AccountTypeRoth        StandardAccountType = "roth"
	AccountType529         StandardAccountType = "529"
)

// IsValid checks if the account type is valid
func (a StandardAccountType) IsValid() bool {
	switch a {
	case AccountTypeCash, AccountTypeChecking, AccountTypeSavings, AccountTypeTaxable, AccountTypeTaxDeferred, AccountTypeRoth, AccountType529:
		return true
	default:
		return false
	}
}

// String returns the string representation
func (a StandardAccountType) String() string {
	return string(a)
}

// SimulatorEventType represents event classification
type SimulatorEventType string

const (
	EventTypeIncome         SimulatorEventType = "INCOME"
	EventTypeExpense        SimulatorEventType = "EXPENSE"
	EventTypeContribution   SimulatorEventType = "CONTRIBUTION"
	EventTypeWithdrawal     SimulatorEventType = "WITHDRAWAL"
	EventTypeTransfer       SimulatorEventType = "TRANSFER"
	EventTypeRothConversion SimulatorEventType = "ROTH_CONVERSION"
	EventTypeTaxPayment     SimulatorEventType = "TAX_PAYMENT"
	EventTypeRMD            SimulatorEventType = "RMD"
)

// IsValid checks if the event type is valid
func (e SimulatorEventType) IsValid() bool {
	switch e {
	case EventTypeIncome, EventTypeExpense, EventTypeContribution,
		EventTypeWithdrawal, EventTypeTransfer, EventTypeRothConversion,
		EventTypeTaxPayment, EventTypeRMD:
		return true
	default:
		return false
	}
}

// FilingStatus represents tax filing status
type FilingStatus string

const (
	FilingStatusSingle            FilingStatus = "single"
	FilingStatusMarriedJointly    FilingStatus = "married_jointly"
	FilingStatusMarriedSeparately FilingStatus = "married_separately"
	FilingStatusHeadOfHousehold   FilingStatus = "head_of_household"
)

// IsValid checks if the filing status is valid
func (f FilingStatus) IsValid() bool {
	switch f {
	case FilingStatusSingle, FilingStatusMarriedJointly,
		FilingStatusMarriedSeparately, FilingStatusHeadOfHousehold:
		return true
	default:
		return false
	}
}

// =============================================================================
// EVENT STRUCTS - Mirror TypeScript exactly
// =============================================================================

// BaseSimulatorEvent contains fields common to all events
type BaseSimulatorEvent struct {
	ID             string             `json:"id"`
	Name           string             `json:"name"`
	Type           SimulatorEventType `json:"type"`
	MonthOffset    MonthOffset        `json:"monthOffset"`
	EndMonthOffset *MonthOffset       `json:"endMonthOffset,omitempty"`
	MonthlyAmount  MonthlyAmount      `json:"monthlyAmount"`
}

// Validate performs basic validation on the base event
func (e *BaseSimulatorEvent) Validate() error {
	if e.ID == "" {
		return fmt.Errorf("event ID cannot be empty")
	}
	if e.Name == "" {
		return fmt.Errorf("event name cannot be empty")
	}
	if !e.Type.IsValid() {
		return fmt.Errorf("invalid event type: %s", e.Type)
	}
	if err := e.MonthOffset.Validate(); err != nil {
		return fmt.Errorf("invalid monthOffset: %w", err)
	}
	if e.EndMonthOffset != nil {
		if err := e.EndMonthOffset.Validate(); err != nil {
			return fmt.Errorf("invalid endMonthOffset: %w", err)
		}
		if *e.EndMonthOffset <= e.MonthOffset {
			return fmt.Errorf("endMonthOffset (%d) must be greater than monthOffset (%d)",
				e.EndMonthOffset.ToInt(), e.MonthOffset.ToInt())
		}
	}
	if err := e.MonthlyAmount.Validate(); err != nil {
		return fmt.Errorf("invalid monthlyAmount: %w", err)
	}
	return nil
}

// IncomeEvent represents income flowing into cash
type IncomeEvent struct {
	BaseSimulatorEvent
	TargetAccount string `json:"targetAccount"` // Always "cash"
}

func (e *IncomeEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeIncome {
		return fmt.Errorf("invalid type for IncomeEvent: %s", e.Type)
	}
	if e.TargetAccount != "cash" {
		return fmt.Errorf("IncomeEvent targetAccount must be 'cash', got: %s", e.TargetAccount)
	}
	return nil
}

// ExpenseEvent represents money flowing out
type ExpenseEvent struct {
	BaseSimulatorEvent
	SourceAccount *StandardAccountType `json:"sourceAccount,omitempty"`
}

func (e *ExpenseEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeExpense {
		return fmt.Errorf("invalid type for ExpenseEvent: %s", e.Type)
	}
	if e.SourceAccount != nil && !e.SourceAccount.IsValid() {
		return fmt.Errorf("invalid sourceAccount: %s", *e.SourceAccount)
	}
	return nil
}

// ContributionEvent represents money flowing into investment accounts
type ContributionEvent struct {
	BaseSimulatorEvent
	TargetAccount   StandardAccountType `json:"targetAccount"`
	IsEmployerMatch *bool               `json:"isEmployerMatch,omitempty"`
}

func (e *ContributionEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeContribution {
		return fmt.Errorf("invalid type for ContributionEvent: %s", e.Type)
	}
	if !e.TargetAccount.IsValid() {
		return fmt.Errorf("invalid targetAccount: %s", e.TargetAccount)
	}
	return nil
}

// WithdrawalEvent represents money flowing out of investment accounts
type WithdrawalEvent struct {
	BaseSimulatorEvent
	SourceAccount StandardAccountType `json:"sourceAccount"`
	Reason        *string             `json:"reason,omitempty"`
}

func (e *WithdrawalEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeWithdrawal {
		return fmt.Errorf("invalid type for WithdrawalEvent: %s", e.Type)
	}
	if !e.SourceAccount.IsValid() {
		return fmt.Errorf("invalid sourceAccount: %s", e.SourceAccount)
	}
	if e.Reason != nil {
		validReasons := []string{"retirement", "emergency", "rmd", "other"}
		isValid := false
		for _, valid := range validReasons {
			if *e.Reason == valid {
				isValid = true
				break
			}
		}
		if !isValid {
			return fmt.Errorf("invalid reason: %s", *e.Reason)
		}
	}
	return nil
}

// TransferEvent represents money moving between accounts
type TransferEvent struct {
	BaseSimulatorEvent
	SourceAccount StandardAccountType `json:"sourceAccount"`
	TargetAccount StandardAccountType `json:"targetAccount"`
}

func (e *TransferEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeTransfer {
		return fmt.Errorf("invalid type for TransferEvent: %s", e.Type)
	}
	if !e.SourceAccount.IsValid() {
		return fmt.Errorf("invalid sourceAccount: %s", e.SourceAccount)
	}
	if !e.TargetAccount.IsValid() {
		return fmt.Errorf("invalid targetAccount: %s", e.TargetAccount)
	}
	if e.SourceAccount == e.TargetAccount {
		return fmt.Errorf("sourceAccount and targetAccount cannot be the same: %s", e.SourceAccount)
	}
	return nil
}

// RothConversionEvent represents tax-deferred to Roth conversion
type RothConversionEvent struct {
	BaseSimulatorEvent
	SourceAccount string `json:"sourceAccount"` // Always "tax_deferred"
	TargetAccount string `json:"targetAccount"` // Always "roth"
}

func (e *RothConversionEvent) Validate() error {
	if err := e.BaseSimulatorEvent.Validate(); err != nil {
		return err
	}
	if e.Type != EventTypeRothConversion {
		return fmt.Errorf("invalid type for RothConversionEvent: %s", e.Type)
	}
	if e.SourceAccount != "tax_deferred" {
		return fmt.Errorf("RothConversionEvent sourceAccount must be 'tax_deferred', got: %s", e.SourceAccount)
	}
	if e.TargetAccount != "roth" {
		return fmt.Errorf("RothConversionEvent targetAccount must be 'roth', got: %s", e.TargetAccount)
	}
	return nil
}

// =============================================================================
// CONFIGURATION STRUCTS
// =============================================================================

// AccountBalance represents an account's current balance
type AccountBalance struct {
	AccountType StandardAccountType `json:"accountType"`
	Balance     MonthlyAmount       `json:"balance"`
	Basis       *MonthlyAmount      `json:"basis,omitempty"`
}

func (a *AccountBalance) Validate() error {
	if !a.AccountType.IsValid() {
		return fmt.Errorf("invalid accountType: %s", a.AccountType)
	}
	if err := a.Balance.Validate(); err != nil {
		return fmt.Errorf("invalid balance: %w", err)
	}
	if a.Basis != nil {
		if err := a.Basis.Validate(); err != nil {
			return fmt.Errorf("invalid basis: %w", err)
		}
		if *a.Basis > a.Balance {
			return fmt.Errorf("basis (%v) cannot exceed balance (%v)",
				a.Basis.ToFloat64(), a.Balance.ToFloat64())
		}
	}
	return nil
}

// MarketReturns represents expected market returns
type MarketReturns struct {
	Stocks Percentage `json:"stocks"`
	Bonds  Percentage `json:"bonds"`
	Cash   Percentage `json:"cash"`
}

func (m *MarketReturns) Validate() error {
	if err := m.Stocks.Validate(); err != nil {
		return fmt.Errorf("invalid stocks return: %w", err)
	}
	if err := m.Bonds.Validate(); err != nil {
		return fmt.Errorf("invalid bonds return: %w", err)
	}
	if err := m.Cash.Validate(); err != nil {
		return fmt.Errorf("invalid cash return: %w", err)
	}
	return nil
}

// TaxConfig represents tax configuration
type TaxConfig struct {
	FilingStatus FilingStatus `json:"filingStatus"`
	State        string       `json:"state"`
}

func (t *TaxConfig) Validate() error {
	if !t.FilingStatus.IsValid() {
		return fmt.Errorf("invalid filingStatus: %s", t.FilingStatus)
	}
	return nil
}

// CashAccountConfig represents interest rates for cash accounts
type CashAccountConfig struct {
	CheckingInterestRate Percentage `json:"checkingInterestRate"` // Annual interest rate for checking accounts (typically 0.01%)
	SavingsInterestRate  Percentage `json:"savingsInterestRate"`  // Annual interest rate for savings accounts (typically 4-5%)
}

func (c *CashAccountConfig) Validate() error {
	if err := c.CheckingInterestRate.Validate(); err != nil {
		return fmt.Errorf("invalid checkingInterestRate: %w", err)
	}
	if err := c.SavingsInterestRate.Validate(); err != nil {
		return fmt.Errorf("invalid savingsInterestRate: %w", err)
	}
	return nil
}

// SimulatorConfig represents complete simulation configuration
type SimulatorConfig struct {
	SimulationMonths  MonthOffset       `json:"simulationMonths"`
	InflationRate     Percentage        `json:"inflationRate"`
	MarketReturns     MarketReturns     `json:"marketReturns"`
	TaxConfig         TaxConfig         `json:"taxConfig"`
	CashAccountConfig CashAccountConfig `json:"cashAccountConfig"`
}

func (s *SimulatorConfig) Validate() error {
	if err := s.SimulationMonths.Validate(); err != nil {
		return fmt.Errorf("invalid simulationMonths: %w", err)
	}
	if s.SimulationMonths <= 0 {
		return fmt.Errorf("simulationMonths must be positive, got: %d", s.SimulationMonths.ToInt())
	}
	if err := s.InflationRate.Validate(); err != nil {
		return fmt.Errorf("invalid inflationRate: %w", err)
	}
	if err := s.MarketReturns.Validate(); err != nil {
		return fmt.Errorf("invalid marketReturns: %w", err)
	}
	if err := s.TaxConfig.Validate(); err != nil {
		return fmt.Errorf("invalid taxConfig: %w", err)
	}
	if err := s.CashAccountConfig.Validate(); err != nil {
		return fmt.Errorf("invalid cashAccountConfig: %w", err)
	}
	return nil
}

// =============================================================================
// INPUT/OUTPUT STRUCTS
// =============================================================================

// SimulatorInput represents the complete input to the simulator
type SimulatorInput struct {
	Events          []json.RawMessage `json:"events"` // Events as raw JSON for polymorphism
	InitialBalances []AccountBalance  `json:"initialBalances"`
	Config          SimulatorConfig   `json:"config"`
}

func (s *SimulatorInput) Validate() error {
	if len(s.Events) == 0 {
		return fmt.Errorf("events cannot be empty")
	}

	for i, balance := range s.InitialBalances {
		if err := balance.Validate(); err != nil {
			return fmt.Errorf("invalid initialBalance[%d]: %w", i, err)
		}
	}

	if err := s.Config.Validate(); err != nil {
		return fmt.Errorf("invalid config: %w", err)
	}

	return nil
}

// CashFlow represents cash flow for a period
type CashFlow struct {
	Income   MonthlyAmount `json:"income"`
	Expenses MonthlyAmount `json:"expenses"`
	Taxes    MonthlyAmount `json:"taxes"`
}

// MonthlySnapshot represents account state at a specific month
type MonthlySnapshot struct {
	MonthOffset MonthOffset      `json:"monthOffset"`
	Accounts    []AccountBalance `json:"accounts"`
	NetWorth    MonthlyAmount    `json:"netWorth"`
	CashFlow    CashFlow         `json:"cashFlow"`
}

// YearlySnapshot represents account state at year end
type YearlySnapshot struct {
	Year                int              `json:"year"`
	EndingNetWorth      MonthlyAmount    `json:"endingNetWorth"`
	TotalIncome         float64          `json:"totalIncome"`         // Annual total
	TotalExpenses       float64          `json:"totalExpenses"`       // Annual total
	TotalTaxes          float64          `json:"totalTaxes"`          // Annual total
	TotalInterestIncome float64          `json:"totalInterestIncome"` // Annual interest income from cash accounts
	AccountBalances     []AccountBalance `json:"accountBalances"`
}

// SimulationSummary represents key simulation results
type SimulationSummary struct {
	SuccessRate         Percentage    `json:"successRate"`
	MedianFinalNetWorth MonthlyAmount `json:"medianFinalNetWorth"`
	Percentile25        MonthlyAmount `json:"percentile25"`
	Percentile75        MonthlyAmount `json:"percentile75"`
}

// SimulatorOutput represents the complete simulation result
type SimulatorOutput struct {
	Months  []MonthlySnapshot `json:"months"`
	Years   []YearlySnapshot  `json:"years"`
	Summary SimulationSummary `json:"summary"`
}

// Type validation functions

// =============================================================================
// VALIDATION FUNCTIONS
// =============================================================================

// ValidateSimulatorEvent validates any simulator event using type discrimination
func ValidateSimulatorEvent(eventJSON json.RawMessage) error {
	// First parse just the type field
	var typeCheck struct {
		Type SimulatorEventType `json:"type"`
	}

	if err := json.Unmarshal(eventJSON, &typeCheck); err != nil {
		return fmt.Errorf("invalid JSON: %w", err)
	}

	if !typeCheck.Type.IsValid() {
		return fmt.Errorf("invalid event type: %s", typeCheck.Type)
	}

	// Parse and validate specific event type
	switch typeCheck.Type {
	case EventTypeIncome:
		var event IncomeEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid IncomeEvent JSON: %w", err)
		}
		return event.Validate()

	case EventTypeExpense:
		var event ExpenseEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid ExpenseEvent JSON: %w", err)
		}
		return event.Validate()

	case EventTypeContribution:
		var event ContributionEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid ContributionEvent JSON: %w", err)
		}
		return event.Validate()

	case EventTypeWithdrawal:
		var event WithdrawalEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid WithdrawalEvent JSON: %w", err)
		}
		return event.Validate()

	case EventTypeTransfer:
		var event TransferEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid TransferEvent JSON: %w", err)
		}
		return event.Validate()

	case EventTypeRothConversion:
		var event RothConversionEvent
		if err := json.Unmarshal(eventJSON, &event); err != nil {
			return fmt.Errorf("invalid RothConversionEvent JSON: %w", err)
		}
		return event.Validate()

	default:
		return fmt.Errorf("unsupported event type: %s", typeCheck.Type)
	}
}

// ValidateSimulatorInput validates the complete simulator input
func ValidateSimulatorInput(inputJSON []byte) (*SimulatorInput, error) {
	var input SimulatorInput

	if err := json.Unmarshal(inputJSON, &input); err != nil {
		return nil, fmt.Errorf("invalid SimulatorInput JSON: %w", err)
	}

	// Validate structure
	if err := input.Validate(); err != nil {
		return nil, err
	}

	// Validate each event
	for i, eventJSON := range input.Events {
		if err := ValidateSimulatorEvent(eventJSON); err != nil {
			return nil, fmt.Errorf("invalid event[%d]: %w", i, err)
		}
	}

	return &input, nil
}

// JSON marshalling helpers

// =============================================================================
// JSON MARSHALLING HELPERS
// =============================================================================

// ParseSimulatorEvents parses and validates events from raw JSON
func ParseSimulatorEvents(eventsJSON []json.RawMessage) ([]interface{}, error) {
	events := make([]interface{}, 0, len(eventsJSON))

	for i, eventJSON := range eventsJSON {
		// Determine event type
		var typeCheck struct {
			Type SimulatorEventType `json:"type"`
		}

		if err := json.Unmarshal(eventJSON, &typeCheck); err != nil {
			return nil, fmt.Errorf("event[%d]: invalid JSON: %w", i, err)
		}

		// Parse specific event type
		switch typeCheck.Type {
		case EventTypeIncome:
			var event IncomeEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid IncomeEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		case EventTypeExpense:
			var event ExpenseEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid ExpenseEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		case EventTypeContribution:
			var event ContributionEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid ContributionEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		case EventTypeWithdrawal:
			var event WithdrawalEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid WithdrawalEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		case EventTypeTransfer:
			var event TransferEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid TransferEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		case EventTypeRothConversion:
			var event RothConversionEvent
			if err := json.Unmarshal(eventJSON, &event); err != nil {
				return nil, fmt.Errorf("event[%d]: invalid RothConversionEvent: %w", i, err)
			}
			if err := event.Validate(); err != nil {
				return nil, fmt.Errorf("event[%d]: validation failed: %w", i, err)
			}
			events = append(events, &event)

		default:
			return nil, fmt.Errorf("event[%d]: unsupported type: %s", i, typeCheck.Type)
		}
	}

	return events, nil
}

// MarshalSimulatorOutput converts output to JSON with proper formatting
func MarshalSimulatorOutput(output *SimulatorOutput) ([]byte, error) {
	return json.MarshalIndent(output, "", "  ")
}
