<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Chubby Simulation Viewer</title>
  <script src="/pako.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; background: #f9f9f9; font-family: ui-sans-serif, -apple-system, system-ui, "Segoe UI", sans-serif; }
    @media (prefers-color-scheme: dark) { html, body { background: #0d0d0d; color: #fff; } }
    iframe { width: 100%; border: none; display: block; }
    .error { padding: 60px 24px; text-align: center; }
    .error h2 { font-size: 18px; color: #9a6458; margin-bottom: 12px; }
    .error p { font-size: 14px; color: #888; margin-bottom: 16px; }
    .error .hint { font-size: 12px; color: #666; background: #f5f5f5; padding: 12px; border-radius: 8px; max-width: 400px; margin: 0 auto; }
    @media (prefers-color-scheme: dark) { .error h2 { color: #c4897c; } .error .hint { background: #1a1a1a; } }
  </style>
</head>
<body>
  <div id="error" class="error" style="display:none">
    <h2>Unable to Load</h2>
    <p id="error-msg"></p>
    <div class="hint">This viewer reads data from the URL fragment. If you navigated here directly, the simulation data may be missing. Try running a new simulation.</div>
  </div>
  <iframe id="widget" src="/simulation-widget.html" style="display:none"></iframe>

  <script>
    function showError(msg) {
      document.getElementById('error-msg').textContent = msg;
      document.getElementById('error').style.display = 'block';
    }

    function init() {
      const hash = window.location.hash;
      if (!hash || hash.length < 2) { showError('No simulation data in URL.'); return; }

      // Extract payload directly — do NOT use URLSearchParams (it converts + to space)
      const raw = hash.slice(1);
      if (!raw.startsWith('d=')) { showError('Invalid URL format.'); return; }
      const payload = raw.slice(2);
      if (!payload) { showError('No payload in URL.'); return; }

      try {
        // Decode base64 (handle both standard and URL-safe base64)
        const std = payload.replace(/-/g, '+').replace(/_/g, '/');
        const padded = std + '='.repeat((4 - std.length % 4) % 4);
        const binary = atob(padded);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const decompressed = pako.inflate(bytes, { to: 'string' });
        const data = JSON.parse(decompressed);

        // Show iframe and send data to the widget
        const iframe = document.getElementById('widget');
        iframe.style.display = 'block';
        iframe.onload = () => {
          iframe.contentWindow.postMessage({ type: 'simulationResult', result: data }, '*');
        };
        // If iframe already loaded, send immediately
        if (iframe.contentDocument?.readyState === 'complete') {
          iframe.contentWindow.postMessage({ type: 'simulationResult', result: data }, '*');
        }

        // Auto-resize iframe to match widget content height
        function resizeIframe() {
          try {
            const h = iframe.contentDocument?.documentElement?.scrollHeight;
            if (h) iframe.style.height = h + 'px';
          } catch (e) { /* cross-origin fallback */ }
        }
        iframe.onload = function() {
          iframe.contentWindow.postMessage({ type: 'simulationResult', result: data }, '*');
          resizeIframe();
          // Re-check height after widget renders
          setTimeout(resizeIframe, 100);
          setTimeout(resizeIframe, 500);
        };
        // Listen for resize messages from widget
        window.addEventListener('message', e => {
          if (e.data?.type === 'resize' && e.data.height) {
            iframe.style.height = e.data.height + 'px';
          }
        });

      } catch (err) {
        console.error('[Chubby Viewer] Failed:', err);
        showError('Failed to decompress simulation data: ' + err.message);
      }
    }

    // On some hosts (Cloudflare Pages), DOMContentLoaded fires before
    // the hash fragment is available. Retry briefly if hash is empty.
    var _initDone = false;
    function tryInit() {
      if (_initDone) return;
      if (window.location.hash && window.location.hash.length >= 2) {
        _initDone = true;
        init();
      }
    }
    document.addEventListener('DOMContentLoaded', function() {
      tryInit();
      if (!_initDone) {
        // Retry a few times in case hash arrives late
        setTimeout(tryInit, 50);
        setTimeout(tryInit, 200);
        setTimeout(function() {
          if (!_initDone) init(); // final attempt — will show error if still empty
        }, 500);
      }
    });
    window.addEventListener('hashchange', tryInit);
  </script>
</body>
</html>
