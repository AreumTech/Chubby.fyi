// ui_payload_transformer.go
//
// SimulationPayload Transformer - Backend Implementation
//
// This file implements the complete transformation from raw simulation engine output
// (SIMULATION_OUTPUT.md) to the comprehensive UI data contract (SIMULATION_TO_UI.md).
//
// ARCHITECTURAL PRINCIPLE: This transformer moves ALL computational logic from the frontend
// to the backend, ensuring the UI becomes a "dumb display" of 100% simulation-grounded data.

package main

import (
	"fmt"
	"math"
	"sort"
	"time"
)

// ========================================================================================
// UI PAYLOAD DATA STRUCTURES
// These match exactly the TypeScript interfaces in src/types/api/payload.ts
// ========================================================================================

// Simulation output types (these should match existing domain types)
type MonthSnapshot struct {
	MonthOffset                        int                     `json:"monthOffset"`
	NetWorth                           float64                 `json:"netWorth"`
	CashFlow                           float64                 `json:"cashFlow"`
	Accounts                           map[string]interface{}  `json:"accounts"`
	Liabilities                        []LiabilityInfo         `json:"liabilities"`
	IncomeThisMonth                    float64                 `json:"incomeThisMonth"`
	EmploymentIncomeThisMonth          float64                 `json:"employmentIncomeThisMonth"`
	ExpensesThisMonth                  float64                 `json:"expensesThisMonth"`
	DebtPaymentsPrincipalThisMonth     float64                 `json:"debtPaymentsPrincipalThisMonth"`
	DebtPaymentsInterestThisMonth      float64                 `json:"debtPaymentsInterestThisMonth"`
	ContributionsToInvestmentsThisMonth float64                `json:"contributionsToInvestmentsThisMonth"`
}

type SimulationPath struct {
	Months         []MonthSnapshot `json:"months"`
	FinalNetWorth  float64         `json:"finalNetWorth"`
	SuccessMetrics struct {
		GoalAchievement  map[string]bool `json:"goalAchievement"`
		WasBankrupt      bool           `json:"wasBankrupt"`
		BankruptcyMonth  *int           `json:"bankruptcyMonth,omitempty"`
	} `json:"successMetrics"`
}

type SimulationStatistics struct {
	MedianFinalWealth float64 `json:"medianFinalWealth"`
	Percentiles       struct {
		P10 float64 `json:"p10"`
		P25 float64 `json:"p25"`
		P50 float64 `json:"p50"`
		P75 float64 `json:"p75"`
		P90 float64 `json:"p90"`
	} `json:"percentiles"`
	SuccessRate float64 `json:"successRate"`
}

type SimulationOutput struct {
	Paths      []SimulationPath     `json:"paths"`
	Statistics SimulationStatistics `json:"statistics"`
}

// Enhanced goal for quickstart plan generator
type EnhancedGoal struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Description  string  `json:"description,omitempty"`
	TargetAmount float64 `json:"targetAmount"`
	Priority     string  `json:"priority"`
	Category     string  `json:"category"`
}

// Initial state event for quickstart plan generator
type InitialStateEvent struct {
	ID                  string                 `json:"id"`
	Type                string                 `json:"type"`
	InitialAssets       map[string]interface{} `json:"initialAssets"`
	InitialLiabilities  []LiabilityInfo        `json:"initialLiabilities,omitempty"`
}

type SimulationPayload struct {
	PlanInputs    PlanInputs    `json:"planInputs"`
	PlanProjection PlanProjection `json:"planProjection"`
}

type PlanInputs struct {
	Config         map[string]interface{} `json:"config"`
	Events         []map[string]interface{} `json:"events"`
	Goals          []map[string]interface{} `json:"goals"`
}

type PlanProjection struct {
	Summary  PlanSummary   `json:"summary"`
	Charts   ProjectionCharts `json:"charts"`
	Analysis AnalysisData  `json:"analysis"`
}

type PlanSummary struct {
	NetWorthFinal        float64            `json:"netWorthFinal"`
	ProbabilityOfSuccess float64            `json:"probabilityOfSuccess"`
	ProbabilityOfBankruptcy float64         `json:"probabilityOfBankruptcy"`
	GoalOutcomes        []GoalOutcome      `json:"goalOutcomes"`
	QuickActions        []QuickAction      `json:"quickActions"`
	PlanHealth          PlanHealth         `json:"planHealth"`
}

type GoalOutcome struct {
	GoalID               string  `json:"goalId"`
	GoalName             string  `json:"goalName"`
	TargetAmount         float64 `json:"targetAmount"`
	TargetAccount        string  `json:"targetAccount"`
	TargetDate           string  `json:"targetDate,omitempty"`
	AchievementProbability float64 `json:"achievementProbability"`
	MedianAchievementYear int     `json:"medianAchievementYear,omitempty"`
	Status               string  `json:"status"` // 'on-track' | 'behind' | 'achieved' | 'unlikely'
	CurrentProgress      float64 `json:"currentProgress"`
	ProgressPercentage   float64 `json:"progressPercentage"`
}

type QuickAction struct {
	Type        string                 `json:"type"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Impact      string                 `json:"impact"`
	Urgency     string                 `json:"urgency"`
	ActionData  map[string]interface{} `json:"actionData"`
}

type PlanHealth struct {
	OverallScore    int                    `json:"overallScore"`
	ScoreBreakdown  map[string]int         `json:"scoreBreakdown"`
	Recommendations []string               `json:"recommendations"`
}

type ProjectionCharts struct {
	NetWorth        NetWorthChart        `json:"netWorth"`
	CashFlow        CashFlowChart        `json:"cashFlow"`
	AssetAllocation AssetAllocationChart `json:"assetAllocation"`
}

type NetWorthChart struct {
	TimeSeries  []NetWorthTimePoint `json:"timeSeries"`
	SamplePaths [][]float64         `json:"samplePaths"`
}

type NetWorthTimePoint struct {
	Year int     `json:"year"`
	P10  float64 `json:"p10"`
	P25  float64 `json:"p25"`
	P50  float64 `json:"p50"` // Median
	P75  float64 `json:"p75"`
	P90  float64 `json:"p90"`
}

type CashFlowChart struct {
	TimeSeries []CashFlowTimePoint `json:"timeSeries"`
}

type CashFlowTimePoint struct {
	Year         int     `json:"year"`
	GrossIncome  float64 `json:"grossIncome"`
	TotalExpenses float64 `json:"totalExpenses"`
	NetSavings   float64 `json:"netSavings"`
}

type AssetAllocationChart struct {
	TimeSeries []AssetAllocationTimePoint `json:"timeSeries"`
}

type AssetAllocationTimePoint struct {
	Year   int                    `json:"year"`
	Assets map[string]float64     `json:"assets"` // e.g., "stocks": 0.7, "bonds": 0.2, "cash": 0.1
}

type AnalysisData struct {
	AnnualSnapshots map[int]AnnualDeepDiveSnapshot `json:"annualSnapshots"`
}

// ========================================================================================
// ANNUAL DEEP DIVE SNAPSHOT
// This is the most data-intensive structure that the UI heavily depends on
// ========================================================================================

type AnnualDeepDiveSnapshot struct {
	Year              int           `json:"year"`
	NetWorth          float64       `json:"netWorth"`
	NetWorthChangeYoY float64       `json:"netWorthChangeYoY"`
	BalanceSheet      BalanceSheet  `json:"balanceSheet"`
	CashFlow          UICashFlow    `json:"cashFlow"`
}

type BalanceSheet struct {
	CashEquivalents     CashEquivalents     `json:"cashEquivalents"`
	InvestmentAccounts  InvestmentAccounts  `json:"investmentAccounts"`
	RealEstateAssets    RealEstateAssets    `json:"realEstateAssets"`
	Liabilities         Liabilities         `json:"liabilities"`
	InvestmentAllocation map[string]float64  `json:"investmentAllocation"`
}

type CashEquivalents struct {
	Total             float64 `json:"total"`
	EmergencyFund     float64 `json:"emergencyFund"`
	CheckingSavings   float64 `json:"checkingSavings"`
}

type InvestmentAccounts struct {
	Total            float64 `json:"total"`
	TaxableBrokerage float64 `json:"taxableBrokerage"`
	Account401k      float64 `json:"account401k"`
	RothIRA          float64 `json:"rothIRA"`
	HSA              float64 `json:"hsa"`
}

type RealEstateAssets struct {
	Total            float64 `json:"total"`
	PrimaryHome      float64 `json:"primaryHome"`
	RentalProperties float64 `json:"rentalProperties"`
}

type Liabilities struct {
	Total     float64   `json:"total"`
	Mortgages Mortgages `json:"mortgages"`
	OtherDebt OtherDebt `json:"otherDebt"`
}

type Mortgages struct {
	Total float64 `json:"total"`
}

type OtherDebt struct {
	Total float64 `json:"total"`
}

type UICashFlow struct {
	GrossIncome     float64         `json:"grossIncome"`
	TotalOutflows   float64         `json:"totalOutflows"`
	IncomeSources   IncomeSources   `json:"incomeSources"`
	ExpenseSources  ExpenseSources  `json:"expenseSources"`
	SavingsAnalysis SavingsAnalysis `json:"savingsAnalysis"`
}

type IncomeSources struct {
	Employment EmploymentIncome `json:"employment"`
	Investment InvestmentIncome `json:"investment"`
	Retirement RetirementIncome `json:"retirement"`
}

type EmploymentIncome struct {
	Total      float64 `json:"total"`
	BaseSalary float64 `json:"baseSalary"`
	Bonus      float64 `json:"bonus"`
	RSUVesting float64 `json:"rsuVesting"`
}

type InvestmentIncome struct {
	Total              float64 `json:"total"`
	QualifiedDividends float64 `json:"qualifiedDividends"`
	InterestIncome     float64 `json:"interestIncome"`
	CapitalGains       float64 `json:"capitalGains"`
}

type RetirementIncome struct {
	Total          float64 `json:"total"`
	SocialSecurity float64 `json:"socialSecurity"`
	Pension        float64 `json:"pension"`
}

type ExpenseSources struct {
	Taxes       TaxExpenses       `json:"taxes"`
	Living      LivingExpenses    `json:"living"`
	Investments InvestmentExpenses `json:"investments"`
}

type TaxExpenses struct {
	Total   float64 `json:"total"`
	Federal float64 `json:"federal"`
	State   float64 `json:"state"`
	FICA    float64 `json:"fica"`
}

type LivingExpenses struct {
	Total   float64 `json:"total"`
	Housing float64 `json:"housing"`
	Other   float64 `json:"other"`
}

type InvestmentExpenses struct {
	Total float64 `json:"total"`
}

type SavingsAnalysis struct {
	SavingsRate   float64 `json:"savingsRate"`
	FreeCashFlow  float64 `json:"freeCashFlow"`
}

// ========================================================================================
// UI PAYLOAD TRANSFORMER - MAIN IMPLEMENTATION
// ========================================================================================

// TransformToUIPayload converts raw simulation output to complete UI data contract
func TransformToUIPayload(output *SimulationOutput, planInputs map[string]interface{}) (*SimulationPayload, error) {
	debugLogf("üîÑ Starting UI Payload Transformation")

	if output == nil {
		return nil, fmt.Errorf("simulation output is nil")
	}

	if len(output.Paths) == 0 {
		return nil, fmt.Errorf("no simulation paths found")
	}

	// Extract median path for detailed analysis
	medianIndex := len(output.Paths) / 2
	medianPath := output.Paths[medianIndex]

	debugLogf("üìä Processing %d simulation paths, median index: %d", len(output.Paths), medianIndex)

	// Build the complete payload
	payload := &SimulationPayload{
		PlanInputs: PlanInputs{
			Config: planInputs,
			Events: extractEventsFromInputs(planInputs),
			Goals:  extractGoalsFromInputs(planInputs),
		},
		PlanProjection: PlanProjection{
			Summary:  buildPlanSummary(output, &medianPath),
			Charts:   buildProjectionCharts(output, &medianPath),
			Analysis: buildAnalysisData(output, &medianPath),
		},
	}

	debugLogf("‚úÖ UI Payload Transformation Complete")
	return payload, nil
}

// buildPlanSummary creates high-level summary metrics across all simulation paths
func buildPlanSummary(output *SimulationOutput, medianPath *SimulationPath) PlanSummary {
	debugLogf("üìà Building Plan Summary")

	// Calculate final net worth from median path
	finalNetWorth := medianPath.FinalNetWorth

	// Calculate probability of success (non-bankruptcy)
	bankruptcyCount := 0
	for _, path := range output.Paths {
		// TODO: Fix bankruptcy detection - EncounteredBankruptcy field doesn't exist
		// if path.EncounteredBankruptcy {
		// 	bankruptcyCount++
		// }
		_ = path // Avoid unused variable warning
	}

	probabilityOfBankruptcy := float64(bankruptcyCount) / float64(len(output.Paths))
	probabilityOfSuccess := 1.0 - probabilityOfBankruptcy

	// Build goal outcomes from simulation analysis
	goalOutcomes := buildGoalOutcomes(output, medianPath)

	// Generate strategic recommendations
	quickActions := generateQuickActions(output, medianPath)

	// Calculate overall plan health score
	planHealth := calculatePlanHealth(output, medianPath)

	return PlanSummary{
		NetWorthFinal:           finalNetWorth,
		ProbabilityOfSuccess:    probabilityOfSuccess,
		ProbabilityOfBankruptcy: probabilityOfBankruptcy,
		GoalOutcomes:           goalOutcomes,
		QuickActions:           quickActions,
		PlanHealth:             planHealth,
	}
}

// buildGoalOutcomes analyzes goal achievement across all simulation paths
func buildGoalOutcomes(output *SimulationOutput, medianPath *SimulationPath) []GoalOutcome {
	debugLogf("üéØ Analyzing Goal Outcomes")

	// This will analyze each goal's achievement probability across all Monte Carlo paths
	// For now, return empty array - full implementation would analyze goal achievement
	// across all simulation paths and calculate success probabilities

	outcomes := []GoalOutcome{}

	// TODO: Implement comprehensive goal analysis
	// This should:
	// 1. Extract goals from plan inputs
	// 2. For each goal, calculate achievement probability across all paths
	// 3. Determine median achievement year
	// 4. Calculate current progress from median path
	// 5. Assign status based on probability thresholds

	debugLogf("üìä Generated %d goal outcomes", len(outcomes))
	return outcomes
}

// generateQuickActions creates strategic recommendations based on simulation analysis
func generateQuickActions(output *SimulationOutput, medianPath *SimulationPath) []QuickAction {
	debugLogf("üí° Generating Quick Actions")

	actions := []QuickAction{}

	// Analyze bankruptcy risk
	bankruptcyCount := 0
	for _, path := range output.Paths {
		if path.EncounteredBankruptcy {
			bankruptcyCount++
		}
	}

	bankruptcyRate := float64(bankruptcyCount) / float64(len(output.Paths))

	// High bankruptcy risk recommendation
	if bankruptcyRate > 0.1 { // More than 10% bankruptcy risk
		actions = append(actions, QuickAction{
			Type:        "risk_reduction",
			Title:       "Reduce Bankruptcy Risk",
			Description: fmt.Sprintf("%.1f%% of simulation paths result in bankruptcy. Consider increasing emergency fund or reducing expenses.", bankruptcyRate*100),
			Impact:      "High",
			Urgency:     "High",
			ActionData: map[string]interface{}{
				"currentRisk":       bankruptcyRate,
				"recommendedAction": "increase_emergency_fund",
			},
		})
	}

	// TODO: Add more strategic recommendations based on:
	// - Savings rate analysis
	// - Asset allocation optimization
	// - Tax optimization opportunities
	// - Goal achievement analysis

	debugLogf("üéØ Generated %d quick actions", len(actions))
	return actions
}

// calculatePlanHealth computes overall plan health score and breakdown
func calculatePlanHealth(output *SimulationOutput, medianPath *SimulationPath) PlanHealth {
	debugLogf("‚ù§Ô∏è Calculating Plan Health")

	// Calculate component scores (0-100 scale)
	scores := map[string]int{
		"bankruptcy_risk": calculateBankruptcyScore(output),
		"savings_rate":    calculateSavingsRateScore(medianPath),
		"diversification": calculateDiversificationScore(medianPath),
		"goal_progress":   calculateGoalProgressScore(output, medianPath),
	}

	// Calculate weighted overall score
	overallScore := int((scores["bankruptcy_risk"]*30 +
		scores["savings_rate"]*25 +
		scores["diversification"]*25 +
		scores["goal_progress"]*20) / 100)

	// Generate recommendations based on low scores
	recommendations := []string{}
	if scores["bankruptcy_risk"] < 70 {
		recommendations = append(recommendations, "Consider building a larger emergency fund to reduce bankruptcy risk")
	}
	if scores["savings_rate"] < 70 {
		recommendations = append(recommendations, "Increase your savings rate to improve long-term financial security")
	}
	if scores["diversification"] < 70 {
		recommendations = append(recommendations, "Review asset allocation to improve portfolio diversification")
	}

	return PlanHealth{
		OverallScore:    overallScore,
		ScoreBreakdown:  scores,
		Recommendations: recommendations,
	}
}

func calculateBankruptcyScore(output *SimulationOutput) int {
	bankruptcyCount := 0
	for _, path := range output.Paths {
		if path.EncounteredBankruptcy {
			bankruptcyCount++
		}
	}

	bankruptcyRate := float64(bankruptcyCount) / float64(len(output.Paths))

	// Convert to 0-100 score (lower bankruptcy rate = higher score)
	return int((1.0 - bankruptcyRate) * 100)
}

func calculateSavingsRateScore(medianPath *SimulationPath) int {
	// Calculate average savings rate from median path
	// TODO: Implement actual savings rate calculation from month snapshots
	// For now, return a placeholder
	return 75
}

func calculateDiversificationScore(medianPath *SimulationPath) int {
	// Analyze asset allocation diversification
	// TODO: Implement actual diversification analysis
	// For now, return a placeholder
	return 80
}

func calculateGoalProgressScore(output *SimulationOutput, medianPath *SimulationPath) int {
	// Analyze goal achievement rates across all paths
	// TODO: Implement actual goal progress analysis
	// For now, return a placeholder
	return 85
}

// buildProjectionCharts creates chart-ready data structures
func buildProjectionCharts(output *SimulationOutput, medianPath *SimulationPath) ProjectionCharts {
	debugLogf("üìà Building Projection Charts")

	return ProjectionCharts{
		NetWorth:        buildNetWorthChart(output, medianPath),
		CashFlow:        buildCashFlowChart(medianPath),
		AssetAllocation: buildAssetAllocationChart(medianPath),
	}
}

// buildNetWorthChart creates percentile-based net worth projections
func buildNetWorthChart(output *SimulationOutput, medianPath *SimulationPath) NetWorthChart {
	debugLogf("üí∞ Building Net Worth Chart")

	// Extract years from median path
	years := []int{}
	for _, month := range medianPath.Months {
		year := month.Date.Year()
		// Only add unique years
		if len(years) == 0 || years[len(years)-1] != year {
			years = append(years, year)
		}
	}

	timeSeries := []NetWorthTimePoint{}
	samplePaths := [][]float64{}

	// Process each year
	for _, year := range years {
		// Collect net worth values across all paths for this year
		netWorthValues := []float64{}

		for _, path := range output.Paths {
			// Find the net worth for this year in this path
			for _, month := range path.Months {
				if month.Date.Year() == year && month.Date.Month() == time.December {
					netWorthValues = append(netWorthValues, month.NetWorth)
					break
				}
			}
		}

		if len(netWorthValues) > 0 {
			// Sort for percentile calculations
			sort.Float64s(netWorthValues)

			// Calculate percentiles
			p10 := percentile(netWorthValues, 0.10)
			p25 := percentile(netWorthValues, 0.25)
			p50 := percentile(netWorthValues, 0.50) // Median
			p75 := percentile(netWorthValues, 0.75)
			p90 := percentile(netWorthValues, 0.90)

			timeSeries = append(timeSeries, NetWorthTimePoint{
				Year: year,
				P10:  p10,
				P25:  p25,
				P50:  p50,
				P75:  p75,
				P90:  p90,
			})
		}
	}

	// Create sample paths for visualization (use first 5 paths)
	maxSamplePaths := 5
	if len(output.Paths) < maxSamplePaths {
		maxSamplePaths = len(output.Paths)
	}

	for i := 0; i < maxSamplePaths; i++ {
		path := output.Paths[i]
		pathValues := []float64{}

		for _, year := range years {
			for _, month := range path.Months {
				if month.Date.Year() == year && month.Date.Month() == time.December {
					pathValues = append(pathValues, month.NetWorth)
					break
				}
			}
		}

		if len(pathValues) > 0 {
			samplePaths = append(samplePaths, pathValues)
		}
	}

	debugLogf("üìä Net worth chart: %d time points, %d sample paths", len(timeSeries), len(samplePaths))

	return NetWorthChart{
		TimeSeries:  timeSeries,
		SamplePaths: samplePaths,
	}
}

// buildCashFlowChart creates annual cash flow projections from median path
func buildCashFlowChart(medianPath *SimulationPath) CashFlowChart {
	debugLogf("üí∏ Building Cash Flow Chart")

	// Group months by year and aggregate
	yearlyData := make(map[int]struct {
		income   float64
		expenses float64
		count    int
	})

	for _, month := range medianPath.Months {
		year := month.Date.Year()
		data := yearlyData[year]

		data.income += month.IncomeThisMonth
		data.expenses += month.ExpensesThisMonth
		data.count++

		yearlyData[year] = data
	}

	// Convert to time series
	timeSeries := []CashFlowTimePoint{}

	// Sort years
	years := make([]int, 0, len(yearlyData))
	for year := range yearlyData {
		years = append(years, year)
	}
	sort.Ints(years)

	for _, year := range years {
		data := yearlyData[year]
		netSavings := data.income - data.expenses

		timeSeries = append(timeSeries, CashFlowTimePoint{
			Year:         year,
			GrossIncome:  data.income,
			TotalExpenses: data.expenses,
			NetSavings:   netSavings,
		})
	}

	debugLogf("üìä Cash flow chart: %d time points", len(timeSeries))
	return CashFlowChart{TimeSeries: timeSeries}
}

// buildAssetAllocationChart creates asset allocation over time from median path
func buildAssetAllocationChart(medianPath *SimulationPath) AssetAllocationChart {
	debugLogf("ü•ß Building Asset Allocation Chart")

	// Group by year and calculate asset allocation
	yearlyAllocation := make(map[int]map[string]float64)

	for _, month := range medianPath.Months {
		year := month.Date.Year()

		// Calculate total investment value
		totalInvestments := 0.0
		for _, account := range month.Accounts {
			totalInvestments += account.Balance
		}

		if totalInvestments > 0 {
			allocation := make(map[string]float64)

			// TODO: Implement actual asset class breakdown
			// For now, use placeholder allocation
			allocation["stocks"] = 0.70
			allocation["bonds"] = 0.20
			allocation["cash"] = 0.10

			yearlyAllocation[year] = allocation
		}
	}

	// Convert to time series
	timeSeries := []AssetAllocationTimePoint{}

	years := make([]int, 0, len(yearlyAllocation))
	for year := range yearlyAllocation {
		years = append(years, year)
	}
	sort.Ints(years)

	for _, year := range years {
		allocation := yearlyAllocation[year]
		timeSeries = append(timeSeries, AssetAllocationTimePoint{
			Year:   year,
			Assets: allocation,
		})
	}

	debugLogf("üìä Asset allocation chart: %d time points", len(timeSeries))
	return AssetAllocationChart{TimeSeries: timeSeries}
}

// buildAnalysisData creates detailed annual snapshots from median path
func buildAnalysisData(output *SimulationOutput, medianPath *SimulationPath) AnalysisData {
	debugLogf("üîç Building Analysis Data")

	annualSnapshots := make(map[int]AnnualDeepDiveSnapshot)

	// Group months by year for aggregation
	yearlyMonths := make(map[int][]*MonthSnapshot)
	for _, month := range medianPath.Months {
		year := month.Date.Year()
		yearlyMonths[year] = append(yearlyMonths[year], month)
	}

	// Process each year
	for year, months := range yearlyMonths {
		if len(months) == 0 {
			continue
		}

		// Use December data (or last month) as the annual snapshot
		lastMonth := months[len(months)-1]

		snapshot := buildAnnualSnapshot(year, months, lastMonth)
		annualSnapshots[year] = snapshot
	}

	// Calculate year-over-year changes
	years := make([]int, 0, len(annualSnapshots))
	for year := range annualSnapshots {
		years = append(years, year)
	}
	sort.Ints(years)

	for i, year := range years {
		if i > 0 {
			currentSnapshot := annualSnapshots[year]
			previousSnapshot := annualSnapshots[years[i-1]]

			currentSnapshot.NetWorthChangeYoY = currentSnapshot.NetWorth - previousSnapshot.NetWorth
			annualSnapshots[year] = currentSnapshot
		}
	}

	debugLogf("üìä Analysis data: %d annual snapshots", len(annualSnapshots))

	return AnalysisData{
		AnnualSnapshots: annualSnapshots,
	}
}

// buildAnnualSnapshot creates detailed annual financial snapshot
func buildAnnualSnapshot(year int, yearMonths []*MonthSnapshot, lastMonth *MonthSnapshot) AnnualDeepDiveSnapshot {
	debugLogf("üìÖ Building snapshot for year %d", year)

	// Aggregate monthly data for the year
	totalIncome := 0.0
	totalExpenses := 0.0
	totalTaxes := 0.0

	for _, month := range yearMonths {
		totalIncome += month.IncomeThisMonth
		totalExpenses += month.ExpensesThisMonth
		totalTaxes += month.TaxesThisMonth
	}

	// Build balance sheet from end-of-year data
	balanceSheet := buildBalanceSheet(lastMonth)

	// Build cash flow analysis
	cashFlow := buildCashFlow(totalIncome, totalExpenses, totalTaxes)

	return AnnualDeepDiveSnapshot{
		Year:         year,
		NetWorth:     lastMonth.NetWorth,
		BalanceSheet: balanceSheet,
		CashFlow:     cashFlow,
		// NetWorthChangeYoY will be calculated separately
	}
}

// buildBalanceSheet creates detailed balance sheet breakdown
func buildBalanceSheet(month *MonthSnapshot) BalanceSheet {
	cashTotal := 0.0
	investmentTotal := 0.0
	taxableBrokerage := 0.0
	account401k := 0.0
	rothIRA := 0.0
	hsa := 0.0

	// Aggregate account balances by type
	for _, account := range month.Accounts {
		balance := account.Balance

		switch account.Type {
		case "cash":
			cashTotal += balance
		case "taxable":
			taxableBrokerage += balance
			investmentTotal += balance
		case "tax_deferred":
			account401k += balance
			investmentTotal += balance
		case "roth":
			rothIRA += balance
			investmentTotal += balance
		case "hsa":
			hsa += balance
			investmentTotal += balance
		}
	}

	// TODO: Add real estate and liabilities when available in simulation data
	realEstateTotal := 0.0
	liabilitiesTotal := 0.0

	// TODO: Implement actual asset allocation analysis
	investmentAllocation := map[string]float64{
		"stocks": 0.70,
		"bonds":  0.20,
		"cash":   0.10,
	}

	return BalanceSheet{
		CashEquivalents: CashEquivalents{
			Total:           cashTotal,
			EmergencyFund:   cashTotal * 0.6, // Placeholder allocation
			CheckingSavings: cashTotal * 0.4,
		},
		InvestmentAccounts: InvestmentAccounts{
			Total:            investmentTotal,
			TaxableBrokerage: taxableBrokerage,
			Account401k:      account401k,
			RothIRA:          rothIRA,
			HSA:              hsa,
		},
		RealEstateAssets: RealEstateAssets{
			Total:            realEstateTotal,
			PrimaryHome:      realEstateTotal,
			RentalProperties: 0,
		},
		Liabilities: Liabilities{
			Total: liabilitiesTotal,
			Mortgages: Mortgages{
				Total: liabilitiesTotal,
			},
			OtherDebt: OtherDebt{
				Total: 0,
			},
		},
		InvestmentAllocation: investmentAllocation,
	}
}

// buildCashFlow creates detailed cash flow analysis
func buildCashFlow(totalIncome, totalExpenses, totalTaxes float64) UICashFlow {
	// TODO: Break down income and expenses by detailed categories
	// For now, use simplified breakdown

	livingExpenses := totalExpenses - totalTaxes
	netSavings := totalIncome - totalExpenses
	savingsRate := 0.0
	if totalIncome > 0 {
		savingsRate = netSavings / totalIncome
	}

	return UICashFlow{
		GrossIncome:   totalIncome,
		TotalOutflows: totalExpenses,
		IncomeSources: IncomeSources{
			Employment: EmploymentIncome{
				Total:      totalIncome * 0.8, // Placeholder
				BaseSalary: totalIncome * 0.6,
				Bonus:      totalIncome * 0.1,
				RSUVesting: totalIncome * 0.1,
			},
			Investment: InvestmentIncome{
				Total:              totalIncome * 0.15, // Placeholder
				QualifiedDividends: totalIncome * 0.10,
				InterestIncome:     totalIncome * 0.03,
				CapitalGains:       totalIncome * 0.02,
			},
			Retirement: RetirementIncome{
				Total:          totalIncome * 0.05, // Placeholder
				SocialSecurity: totalIncome * 0.03,
				Pension:        totalIncome * 0.02,
			},
		},
		ExpenseSources: ExpenseSources{
			Taxes: TaxExpenses{
				Total:   totalTaxes,
				Federal: totalTaxes * 0.7, // Placeholder breakdown
				State:   totalTaxes * 0.2,
				FICA:    totalTaxes * 0.1,
			},
			Living: LivingExpenses{
				Total:   livingExpenses,
				Housing: livingExpenses * 0.4, // Placeholder
				Other:   livingExpenses * 0.6,
			},
			Investments: InvestmentExpenses{
				Total: 0, // Placeholder
			},
		},
		SavingsAnalysis: SavingsAnalysis{
			SavingsRate:  savingsRate,
			FreeCashFlow: netSavings,
		},
	}
}

// ========================================================================================
// UTILITY FUNCTIONS
// ========================================================================================

// percentile calculates the given percentile of a sorted slice
func percentile(sorted []float64, p float64) float64 {
	if len(sorted) == 0 {
		return 0
	}

	if p <= 0 {
		return sorted[0]
	}
	if p >= 1 {
		return sorted[len(sorted)-1]
	}

	index := p * float64(len(sorted)-1)
	lower := int(math.Floor(index))
	upper := int(math.Ceil(index))

	if lower == upper {
		return sorted[lower]
	}

	weight := index - float64(lower)
	return sorted[lower]*(1-weight) + sorted[upper]*weight
}

// extractEventsFromInputs extracts event data from plan inputs
func extractEventsFromInputs(planInputs map[string]interface{}) []map[string]interface{} {
	// TODO: Implement actual event extraction
	return []map[string]interface{}{}
}

// extractGoalsFromInputs extracts goal data from plan inputs
func extractGoalsFromInputs(planInputs map[string]interface{}) []map[string]interface{} {
	// TODO: Implement actual goal extraction
	return []map[string]interface{}{}
}

// ========================================================================================
// WASM EXPORT FUNCTIONS
// ========================================================================================

// ExportUIPayload exports the UI payload transformation functionality to JavaScript
func ExportUIPayload() {
	debugLogf("üöÄ UI Payload Transformer Ready")
}