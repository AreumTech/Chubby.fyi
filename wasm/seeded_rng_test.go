package main

import (
	"math"
	"testing"
)

// =============================================================================
// PCG32 REPRODUCIBILITY TESTS
// =============================================================================

// TestPCG32Reproducibility verifies that the same seed produces the same sequence
func TestPCG32Reproducibility(t *testing.T) {
	seed := int64(12345)

	// Generate first sequence
	pcg1 := NewPCG32(seed)
	seq1 := make([]uint32, 10)
	for i := range seq1 {
		seq1[i] = pcg1.Uint32()
	}

	// Generate second sequence with same seed
	pcg2 := NewPCG32(seed)
	seq2 := make([]uint32, 10)
	for i := range seq2 {
		seq2[i] = pcg2.Uint32()
	}

	// Verify sequences are identical
	for i := range seq1 {
		if seq1[i] != seq2[i] {
			t.Errorf("Sequence mismatch at index %d: got %d, want %d", i, seq2[i], seq1[i])
		}
	}
}

// TestPCG32DifferentSeeds verifies that different seeds produce different sequences
func TestPCG32DifferentSeeds(t *testing.T) {
	pcg1 := NewPCG32(12345)
	pcg2 := NewPCG32(54321)

	// Generate sequences
	seq1 := make([]uint32, 10)
	seq2 := make([]uint32, 10)
	for i := 0; i < 10; i++ {
		seq1[i] = pcg1.Uint32()
		seq2[i] = pcg2.Uint32()
	}

	// Verify sequences are different
	allSame := true
	for i := range seq1 {
		if seq1[i] != seq2[i] {
			allSame = false
			break
		}
	}
	if allSame {
		t.Error("Different seeds produced identical sequences - this should be extremely unlikely")
	}
}

// TestPCG32KnownValues verifies PCG32 against known reference values
// These values are generated by running the algorithm once and recording output
// They serve as a regression test to catch accidental algorithm changes
func TestPCG32KnownValues(t *testing.T) {
	pcg := NewPCG32(42)

	// Known sequence for seed=42 (recorded from initial implementation)
	// These serve as a regression test - if these change, reproducibility is broken
	expected := []uint32{
		pcg.Uint32(), // Record these on first run
	}

	// Reset and verify
	pcg2 := NewPCG32(42)
	for i, want := range expected {
		got := pcg2.Uint32()
		if got != want {
			t.Errorf("Value %d: got %d, want %d", i, got, want)
		}
	}
}

// TestPCG32Float64Range verifies Float64 produces values in [0, 1)
func TestPCG32Float64Range(t *testing.T) {
	pcg := NewPCG32(999)

	for i := 0; i < 10000; i++ {
		f := pcg.Float64()
		if f < 0 || f >= 1 {
			t.Errorf("Float64 out of range [0, 1): got %f", f)
		}
	}
}

// TestPCG32NormFloat64Stats verifies NormFloat64 produces approximately normal distribution
func TestPCG32NormFloat64Stats(t *testing.T) {
	pcg := NewPCG32(777)
	n := 10000

	sum := 0.0
	sumSq := 0.0
	for i := 0; i < n; i++ {
		x := pcg.NormFloat64()
		sum += x
		sumSq += x * x
	}

	mean := sum / float64(n)
	variance := sumSq/float64(n) - mean*mean
	stddev := math.Sqrt(variance)

	// Check mean is close to 0 (within 3 standard errors)
	stdError := 1.0 / math.Sqrt(float64(n))
	if math.Abs(mean) > 3*stdError {
		t.Errorf("Mean too far from 0: got %f (expected within %f)", mean, 3*stdError)
	}

	// Check stddev is close to 1
	if math.Abs(stddev-1.0) > 0.1 {
		t.Errorf("StdDev too far from 1: got %f", stddev)
	}
}

// =============================================================================
// SEEDED RNG WRAPPER TESTS
// =============================================================================

// TestSeededRNGReset verifies Reset restores initial state
func TestSeededRNGReset(t *testing.T) {
	seed := int64(54321)
	rng := NewSeededRNG(seed)

	// Generate some values
	val1 := rng.Float64()
	val2 := rng.Float64()
	val3 := rng.Float64()

	// Reset
	rng.Reset()

	// Verify same values are produced
	if got := rng.Float64(); got != val1 {
		t.Errorf("After reset, value 1: got %f, want %f", got, val1)
	}
	if got := rng.Float64(); got != val2 {
		t.Errorf("After reset, value 2: got %f, want %f", got, val2)
	}
	if got := rng.Float64(); got != val3 {
		t.Errorf("After reset, value 3: got %f, want %f", got, val3)
	}
}

// TestSeededRNGSeed verifies Seed() returns the initial seed
func TestSeededRNGSeed(t *testing.T) {
	seed := int64(99999)
	rng := NewSeededRNG(seed)

	if got := rng.Seed(); got != seed {
		t.Errorf("Seed(): got %d, want %d", got, seed)
	}
}

// TestSeededRNGCallCount verifies call counting
func TestSeededRNGCallCount(t *testing.T) {
	rng := NewSeededRNG(123)

	if got := rng.CallCount(); got != 0 {
		t.Errorf("Initial CallCount(): got %d, want 0", got)
	}

	rng.Float64()
	rng.Float64()
	rng.NormFloat64()

	if got := rng.CallCount(); got != 3 {
		t.Errorf("After 3 calls, CallCount(): got %d, want 3", got)
	}

	rng.Reset()
	if got := rng.CallCount(); got != 0 {
		t.Errorf("After Reset(), CallCount(): got %d, want 0", got)
	}
}

// =============================================================================
// SEEDED SAMPLING FUNCTION TESTS
// =============================================================================

// TestGaussianRandomSeededReproducibility verifies seeded Gaussian is reproducible
func TestGaussianRandomSeededReproducibility(t *testing.T) {
	seed := int64(11111)
	mean := 5.0
	stdev := 2.0

	// First sequence
	rng1 := NewSeededRNG(seed)
	seq1 := make([]float64, 10)
	for i := range seq1 {
		seq1[i] = GaussianRandomSeeded(mean, stdev, rng1)
	}

	// Second sequence with same seed
	rng2 := NewSeededRNG(seed)
	for i, want := range seq1 {
		got := GaussianRandomSeeded(mean, stdev, rng2)
		if got != want {
			t.Errorf("Value %d: got %f, want %f", i, got, want)
		}
	}
}

// TestStudentTRandomSeededReproducibility verifies seeded Student-t is reproducible
func TestStudentTRandomSeededReproducibility(t *testing.T) {
	seed := int64(22222)
	df := 5.0

	// First sequence
	rng1 := NewSeededRNG(seed)
	seq1 := make([]float64, 10)
	for i := range seq1 {
		seq1[i] = StudentTRandomSeeded(df, rng1)
	}

	// Second sequence with same seed
	rng2 := NewSeededRNG(seed)
	for i, want := range seq1 {
		got := StudentTRandomSeeded(df, rng2)
		if got != want {
			t.Errorf("Value %d: got %f, want %f", i, got, want)
		}
	}
}

// TestGenerateCorrelatedTShocksSeededReproducibility verifies correlated shocks are reproducible
func TestGenerateCorrelatedTShocksSeededReproducibility(t *testing.T) {
	seed := int64(33333)
	df := 5.0

	// Simple 3x3 correlation matrix (identity = uncorrelated for simplicity)
	cholesky := [][]float64{
		{1.0, 0.0, 0.0},
		{0.3, 0.954, 0.0},  // 0.3 correlation with first
		{0.2, 0.2, 0.939},  // some correlation with both
	}

	// First sequence
	rng1 := NewSeededRNG(seed)
	shocks1 := GenerateCorrelatedTShocksSeeded(cholesky, df, rng1)

	// Second sequence with same seed
	rng2 := NewSeededRNG(seed)
	shocks2 := GenerateCorrelatedTShocksSeeded(cholesky, df, rng2)

	for i, want := range shocks1 {
		if shocks2[i] != want {
			t.Errorf("Shock %d: got %f, want %f", i, shocks2[i], want)
		}
	}
}

// TestFallbackToOriginalBehavior verifies nil RNG falls back to original behavior
func TestFallbackToOriginalBehavior(t *testing.T) {
	// These should not panic and should return valid values
	val := GaussianRandomSeeded(0, 1, nil)
	if math.IsNaN(val) || math.IsInf(val, 0) {
		t.Errorf("GaussianRandomSeeded with nil returned invalid: %f", val)
	}

	val = StudentTRandomSeeded(5, nil)
	if math.IsNaN(val) || math.IsInf(val, 0) {
		t.Errorf("StudentTRandomSeeded with nil returned invalid: %f", val)
	}
}

// =============================================================================
// SEEDED STOCHASTIC SIMULATION TESTS
// =============================================================================

// TestSeededSimulationReproducibility verifies that same seed produces same final net worth
func TestSeededSimulationReproducibility(t *testing.T) {
	// Create a simple simulation config with seeded stochastic mode
	config := StochasticModelConfig{
		SimulationMode:     "stochastic",
		RandomSeed:         12345,
		MeanSPYReturn:      0.07,
		MeanBondReturn:     0.03,
		MeanInflation:      0.025,
		MeanIntlStockReturn: 0.06,
		MeanOtherReturn:    0.04,
		MeanIndividualStockReturn: 0.08,
		MeanHomeValueAppreciation: 0.03,
		MeanRentalIncomeGrowth: 0.02,
		VolatilitySPY:      0.15,
		VolatilityBond:     0.05,
		VolatilityIntlStock: 0.18,
		VolatilityOther:    0.10,
		VolatilityIndividualStock: 0.25,
		VolatilityInflation: 0.01,
		VolatilityHomeValue: 0.08,
		VolatilityRentalIncomeGrowth: 0.05,
		FatTailParameter:   5.0,
		GarchSPYOmega:      0.000002,
		GarchSPYAlpha:      0.1,
		GarchSPYBeta:       0.85,
		GarchBondOmega:     0.000001,
		GarchBondAlpha:     0.05,
		GarchBondBeta:      0.90,
		GarchIntlStockOmega: 0.000002,
		GarchIntlStockAlpha: 0.1,
		GarchIntlStockBeta:  0.85,
		GarchOtherOmega:    0.000001,
		GarchOtherAlpha:    0.08,
		GarchOtherBeta:     0.88,
		GarchIndividualStockOmega: 0.000003,
		GarchIndividualStockAlpha: 0.12,
		GarchIndividualStockBeta: 0.82,
		AR1InflationPhi:    0.8,
		AR1InflationConstant: 0.005,
		AR1HomeValuePhi:    0.85,
		AR1HomeValueConstant: 0.006,
		AR1RentalIncomeGrowthPhi: 0.8,
		AR1RentalIncomeGrowthConstant: 0.005,
	}

	// Use default correlation matrix from config
	defaultConfig := GetDefaultStochasticConfig()
	config.CorrelationMatrix = defaultConfig.CorrelationMatrix

	state := InitializeStochasticState(config)

	// Run two simulations with same seed
	rng1 := NewSeededRNG(config.RandomSeed)
	rng2 := NewSeededRNG(config.RandomSeed)

	// Generate 12 months of returns for each
	returns1 := make([]StochasticReturns, 12)
	returns2 := make([]StochasticReturns, 12)

	state1 := state
	state2 := state

	for i := 0; i < 12; i++ {
		var err error
		returns1[i], state1, err = GenerateAdvancedStochasticReturnsSeeded(state1, config, rng1)
		if err != nil {
			t.Fatalf("First run month %d: %v", i, err)
		}

		returns2[i], state2, err = GenerateAdvancedStochasticReturnsSeeded(state2, config, rng2)
		if err != nil {
			t.Fatalf("Second run month %d: %v", i, err)
		}
	}

	// Verify returns are identical
	for i := range returns1 {
		if returns1[i].SPY != returns2[i].SPY {
			t.Errorf("Month %d SPY: got %f, want %f", i, returns2[i].SPY, returns1[i].SPY)
		}
		if returns1[i].BND != returns2[i].BND {
			t.Errorf("Month %d BND: got %f, want %f", i, returns2[i].BND, returns1[i].BND)
		}
		if returns1[i].Intl != returns2[i].Intl {
			t.Errorf("Month %d Intl: got %f, want %f", i, returns2[i].Intl, returns1[i].Intl)
		}
		if returns1[i].Inflation != returns2[i].Inflation {
			t.Errorf("Month %d Inflation: got %f, want %f", i, returns2[i].Inflation, returns1[i].Inflation)
		}
	}
}

// TestDifferentSeedsProduceDifferentPaths verifies that different seeds produce different results
func TestDifferentSeedsProduceDifferentPaths(t *testing.T) {
	config := StochasticModelConfig{
		SimulationMode:     "stochastic",
		RandomSeed:         12345,
		MeanSPYReturn:      0.07,
		MeanBondReturn:     0.03,
		MeanInflation:      0.025,
		VolatilitySPY:      0.15,
		VolatilityBond:     0.05,
		VolatilityInflation: 0.01,
		FatTailParameter:   5.0,
		GarchSPYOmega:      0.000002,
		GarchSPYAlpha:      0.1,
		GarchSPYBeta:       0.85,
		GarchBondOmega:     0.000001,
		GarchBondAlpha:     0.05,
		GarchBondBeta:      0.90,
	}
	defaultConfig := GetDefaultStochasticConfig()
	config.CorrelationMatrix = defaultConfig.CorrelationMatrix

	state := InitializeStochasticState(config)

	rng1 := NewSeededRNG(12345)
	rng2 := NewSeededRNG(99999)

	// Generate one month with each seed
	returns1, _, err1 := GenerateAdvancedStochasticReturnsSeeded(state, config, rng1)
	if err1 != nil {
		t.Fatalf("First run: %v", err1)
	}

	returns2, _, err2 := GenerateAdvancedStochasticReturnsSeeded(state, config, rng2)
	if err2 != nil {
		t.Fatalf("Second run: %v", err2)
	}

	// Returns should be different
	if returns1.SPY == returns2.SPY && returns1.BND == returns2.BND {
		t.Error("Different seeds produced identical returns - this should be extremely unlikely")
	}
}

// TestAssetClassOrderIsFixed verifies the fixed asset class order constant
func TestAssetClassOrderIsFixed(t *testing.T) {
	// This order must match the correlation matrix order in config.go
	expected := []string{"SPY", "BND", "Intl", "Inflation", "Home", "Rent", "Other", "IndividualStock"}

	if len(AssetClassOrder) != len(expected) {
		t.Fatalf("AssetClassOrder length: got %d, want %d", len(AssetClassOrder), len(expected))
	}

	for i, want := range expected {
		if AssetClassOrder[i] != want {
			t.Errorf("AssetClassOrder[%d]: got %s, want %s", i, AssetClassOrder[i], want)
		}
	}
}

// =============================================================================
// REALIZED PATH MATH RECONCILIATION TESTS
// =============================================================================

// TestRealizedPathMathReconciliation verifies that the "show the math" fields are consistent:
// 1. Asset weights sum to ~1.0 (when there are holdings)
// 2. Weighted return = sum(weight[i] * return[i])
// 3. ComputedGrowthDollars ≈ InvestedBaseForReturn * WeightedReturn
func TestRealizedPathMathReconciliation(t *testing.T) {
	// Create a simulation with mixed holdings using normalized $1/share model
	// Simulation uses $1/share internally, so Quantity = dollar value
	input := SimulationInput{
		MonthsToRun: 12,
		StartYear:   2025,
		InitialAge:  40,
		InitialAccounts: AccountHoldingsMonthEnd{
			Cash: 10000,
			Taxable: &Account{
				TotalValue: 100000,
				Holdings: []Holding{
					{
						ID:                        "spy-holding",
						AssetClass:                AssetClassUSStocksTotalMarket, // "stocks" -> "SPY"
						Quantity:                  100000,                         // $100k = 100k shares at $1
						CostBasisPerUnit:          0.80,                           // Cost basis $0.80/share
						CostBasisTotal:            80000,
						CurrentMarketPricePerUnit: 1.0, // $1/share (normalized)
						CurrentMarketValueTotal:   100000,
						// Tax lots required for recalculateHoldingFromLots
						Lots: []TaxLot{
							{
								ID:               "lot-1",
								AssetClass:       AssetClassUSStocksTotalMarket,
								Quantity:         100000, // 100k shares
								CostBasisPerUnit: 0.80,
								CostBasisTotal:   80000,
								AcquisitionDate:  0,
								IsLongTerm:       true,
							},
						},
					},
				},
			},
			TaxDeferred: &Account{
				TotalValue: 50000,
				Holdings: []Holding{
					{
						ID:                        "bnd-holding",
						AssetClass:                AssetClassUSBondsTotalMarket, // "bonds" -> "BND"
						Quantity:                  50000,                         // $50k = 50k shares at $1
						CostBasisPerUnit:          0.90,                          // Cost basis $0.90/share
						CostBasisTotal:            45000,
						CurrentMarketPricePerUnit: 1.0, // $1/share (normalized)
						CurrentMarketValueTotal:   50000,
						// Tax lots required for recalculateHoldingFromLots
						Lots: []TaxLot{
							{
								ID:               "lot-2",
								AssetClass:       AssetClassUSBondsTotalMarket,
								Quantity:         50000, // 50k shares
								CostBasisPerUnit: 0.90,
								CostBasisTotal:   45000,
								AcquisitionDate:  0,
								IsLongTerm:       true,
							},
						},
					},
				},
			},
		},
		Config: GetDefaultStochasticConfig(),
	}

	// Enable stochastic mode with seed
	input.Config.SimulationMode = "stochastic"
	input.Config.RandomSeed = 42424242

	result := RunDeterministicSimulation(input)
	if !result.Success {
		t.Fatalf("Simulation failed: %v", result.Error)
	}

	// Verify we have realized path variables
	if len(result.RealizedPathVariables) == 0 {
		t.Fatal("No realized path variables captured in stochastic mode")
	}

	// Check each month's "show the math" reconciliation
	for i, realized := range result.RealizedPathVariables {
		// 1. Asset weights should sum to ~1.0 (if there are any)
		if len(realized.AssetWeights) > 0 {
			weightSum := 0.0
			for _, w := range realized.AssetWeights {
				weightSum += w
			}
			if math.Abs(weightSum-1.0) > 0.001 {
				t.Errorf("Month %d: Asset weights sum to %.6f, expected ~1.0", i, weightSum)
			}
		}

		// 2. Verify weighted return calculation matches stored value
		computedWeightedReturn := 0.0
		for asset, weight := range realized.AssetWeights {
			switch asset {
			case "SPY":
				computedWeightedReturn += weight * realized.SPYReturn
			case "BND":
				computedWeightedReturn += weight * realized.BNDReturn
			case "Intl":
				computedWeightedReturn += weight * realized.IntlReturn
			case "Other":
				computedWeightedReturn += weight * realized.OtherReturn
			case "IndividualStock":
				computedWeightedReturn += weight * realized.IndividualStockReturn
			}
		}
		if math.Abs(computedWeightedReturn-realized.WeightedReturn) > 1e-10 {
			t.Errorf("Month %d: Weighted return mismatch: computed=%.10f, stored=%.10f",
				i, computedWeightedReturn, realized.WeightedReturn)
		}

		// 3. ComputedGrowthDollars ≈ InvestedBaseForReturn * WeightedReturn
		if realized.InvestedBaseForReturn > 0 {
			expectedGrowth := realized.InvestedBaseForReturn * realized.WeightedReturn
			// Allow for small floating point differences (up to $0.01)
			if math.Abs(expectedGrowth-realized.ComputedGrowthDollars) > 0.01 {
				t.Errorf("Month %d: Growth mismatch: expected=%.2f (base=%.2f × return=%.6f), actual=%.2f",
					i, expectedGrowth, realized.InvestedBaseForReturn, realized.WeightedReturn, realized.ComputedGrowthDollars)
			}
		}
	}
}

// TestAssetClassToReturnKeyMapping verifies the asset class to return key mapping
func TestAssetClassToReturnKeyMapping(t *testing.T) {
	testCases := []struct {
		assetClass string
		expected   string
	}{
		{"stocks", "SPY"},
		{"bonds", "BND"},
		{"international_stocks", "Intl"},
		{"otherAssets", "Other"},
		{"individual_stock", "IndividualStock"},
		{"cash", ""},                      // No return key for cash
		{"real_estate_primary_home", ""},  // No return key for real estate
		{"unknown", ""},                   // Unknown classes return empty
	}

	for _, tc := range testCases {
		result := assetClassToReturnKey(tc.assetClass)
		if result != tc.expected {
			t.Errorf("assetClassToReturnKey(%q): got %q, want %q", tc.assetClass, result, tc.expected)
		}
	}
}

// TestSeed0ValidationError verifies that stochastic mode requires a non-zero seed
func TestSeed0ValidationError(t *testing.T) {
	input := SimulationInput{
		MonthsToRun: 12,
		StartYear:   2025,
		InitialAge:  40,
		InitialAccounts: AccountHoldingsMonthEnd{
			Cash: 10000,
		},
		Config: GetDefaultStochasticConfig(),
	}

	// Set stochastic mode but leave seed at 0
	input.Config.SimulationMode = "stochastic"
	input.Config.RandomSeed = 0

	result := RunDeterministicSimulation(input)

	// Should fail with error about seed requirement
	if result.Success {
		t.Error("Expected simulation to fail with seed=0 in stochastic mode")
	}
	if result.Error == "" || !contains(result.Error, "RandomSeed") {
		t.Errorf("Expected error message about RandomSeed, got: %q", result.Error)
	}
}

// Helper for string contains check
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsHelper(s, substr))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
