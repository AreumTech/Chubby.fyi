import { StateCreator } from 'zustand';
import { AppConfig, FinancialEvent } from '../../types';
import { EnhancedGoal } from '../../types/enhanced-goal';
import { DEFAULT_APP_CONFIG } from '../../config/appConfig';
import { InitialStateEvent } from '../../types/events/initial-state';
import { EventPriority, EventType } from '../../types/events/base';
import { FilingStatus } from '@/types';
import {
  migrateActiveStrategiesToEvents,
  needsStrategyMigration,
} from '@/utils/strategyMigration';
import { logger } from '@/utils/logger';
import { PolicySettings, createDefaultPolicySettings } from '@/types/strategies/unified';

export interface Scenario {
  id: string;
  name: string;
  description?: string;
  createdAt: Date;
  lastModified: Date;
  sourcePersona?: string; // e.g., "accelerator" - tracks persona origin
  initialState: InitialStateEvent;
  eventLedger: FinancialEvent[];
  enhancedGoals: EnhancedGoal[];
  policySettings: PolicySettings; // Always-active singleton policies (withdrawal order, cash management, etc.)
  /** @deprecated Use policySettings instead. Kept for backward compatibility during migration. */
  activeStrategies?: ActiveStrategyMetadata[];
}

export interface ActiveStrategyMetadata {
  strategyId: string;
  strategyName: string;
  appliedAt: Date;
  configuration: Record<string, any>;
  policy: {
    summary: string; // Display in sidebar: "Excess cash → 1) 401k → 2) Taxable"
    details?: string[]; // Additional details
  };
  eventIds: string[]; // Events generated by this strategy (user can edit these)
}

export interface PlanSlice {
  // Document state - changes less frequently
  config: AppConfig;
  scenarios: { [scenarioId: string]: Scenario };
  activeScenarioId: string;
  
  // Actions
  setConfig: (config: AppConfig | ((prev: AppConfig) => AppConfig)) => void;
  setScenarios: (scenarios: { [scenarioId: string]: Scenario } | ((prev: { [scenarioId: string]: Scenario }) => { [scenarioId: string]: Scenario })) => void;
  setActiveScenarioId: (id: string) => void;
  
  // Convenience actions for the active scenario
  setInitialState: (initialState: InitialStateEvent) => void;
  setEventLedger: (ledger: FinancialEvent[]) => void;
  setEnhancedGoals: (goals: EnhancedGoal[]) => void;
  setPolicySettings: (settings: PolicySettings | ((prev: PolicySettings) => PolicySettings)) => void;
  updateActiveScenario: (update: Partial<Scenario>) => void;
  
  // Scenario management actions
  duplicateScenario: (scenarioId: string, newName?: string) => string;
  deleteScenario: (scenarioId: string) => void;
  renameScenario: (scenarioId: string, newName: string) => void;
  createPersonaScenario: (personaTitle: string, scenarioData: Omit<Scenario, 'id' | 'name' | 'createdAt' | 'lastModified'>) => string;
  
  // Computed getters
  getActiveScenario: () => Scenario | undefined;
  getEventLedger: () => FinancialEvent[];
  getEnhancedGoals: () => EnhancedGoal[];
  getPolicySettings: () => PolicySettings;
}

const generateId = () => Math.random().toString(36).substr(2, 9);
const DEFAULT_SCENARIO_ID = 'default-scenario';

// Helper function to generate smart names for persona duplicates
const generatePersonaScenarioName = (personaTitle: string, existingScenarios: { [id: string]: Scenario }): string => {
  const scenarios = Object.values(existingScenarios);
  const existingNames = scenarios
    .filter(s => s.sourcePersona === personaTitle.toLowerCase().replace(/\s+/g, '-'))
    .map(s => s.name);
  
  if (!existingNames.includes(personaTitle)) {
    return personaTitle; // "The Accelerator"
  }
  
  let counter = 1;
  let candidateName;
  do {
    candidateName = `${personaTitle} (${counter})`;
    counter++;
  } while (existingNames.includes(candidateName));
  
  return candidateName; // "The Accelerator (1)"
};

// Helper function to create a default initial state
const createDefaultInitialState = (): InitialStateEvent => ({
  id: generateId(),
  type: 'INITIAL_STATE' as const,
  name: 'Initial State',
  priority: EventPriority.USER_ACTION,
  currentAge: 30,
  startYear: new Date().getFullYear(),
  initialMonth: 0,
  filingStatus: FilingStatus.SINGLE,
  numberOfDependents: 0,
  initialCash: 10000,
  initialAccounts: { taxable: [], tax_deferred: [], roth: [] },
  initialLiabilities: [],
  monthOffset: 0,
});

// Helper function to migrate legacy scenarios to include timestamps and convert strategies to events
const migrateLegacyScenario = (scenario: any): Scenario => {
  const now = new Date();
  let eventLedger = scenario.eventLedger || [];

  // Auto-migrate activeStrategies to StrategyPolicyEvents (legacy migration)
  if (needsStrategyMigration(scenario.activeStrategies, eventLedger)) {
    const startYear = scenario.initialState?.startYear || new Date().getFullYear();
    const strategyEvents = migrateActiveStrategiesToEvents(
      scenario.activeStrategies,
      startYear
    );

    if (strategyEvents.length > 0) {
      logger.info(`[planSlice] Auto-migrating ${strategyEvents.length} strategies to events`);
      // Add strategy events after INITIAL_STATE but before other events
      const initialStateEvents = eventLedger.filter((e: any) => e.type === 'INITIAL_STATE');
      const otherEvents = eventLedger.filter((e: any) => e.type !== 'INITIAL_STATE');
      eventLedger = [...initialStateEvents, ...strategyEvents, ...otherEvents];
    }
  }

  // Initialize policySettings if not present
  const policySettings = scenario.policySettings || createDefaultPolicySettings();

  return {
    ...scenario,
    eventLedger,
    policySettings,
    createdAt: scenario.createdAt || now,
    lastModified: scenario.lastModified || now,
    description: scenario.description || undefined,
    sourcePersona: scenario.sourcePersona || undefined,
    // Keep activeStrategies for backward compatibility but migration is done
    activeStrategies: scenario.activeStrategies || undefined
  };
};

export const createPlanSlice: StateCreator<PlanSlice, [], [], PlanSlice> = (set, get) => {
  // Helper to ensure all scenarios have proper timestamps
  const ensureScenarioMetadata = (scenarios: { [id: string]: any }): { [id: string]: Scenario } => {
    const result: { [id: string]: Scenario } = {};
    for (const [id, scenario] of Object.entries(scenarios)) {
      result[id] = migrateLegacyScenario(scenario);
    }
    return result;
  };

  return {
    // Initial state
    config: DEFAULT_APP_CONFIG,
    scenarios: ensureScenarioMetadata({
      [DEFAULT_SCENARIO_ID]: {
        id: DEFAULT_SCENARIO_ID,
        name: 'Base Plan',
        description: 'Default financial planning scenario',
        createdAt: new Date(),
        lastModified: new Date(),
        initialState: createDefaultInitialState(),
        eventLedger: [createDefaultInitialState() as any], // INITIAL_STATE must always be first event
        enhancedGoals: [],
        policySettings: createDefaultPolicySettings()
      }
    }),
    activeScenarioId: DEFAULT_SCENARIO_ID,

  // Actions
  setConfig: (config) => set((state) => ({
    config: typeof config === 'function' ? config(state.config) : config
  })),
  
  setScenarios: (scenarios) => set((state) => {
    const rawScenarios = typeof scenarios === 'function' ? scenarios(state.scenarios) : scenarios;
    return {
      scenarios: ensureScenarioMetadata(rawScenarios)
    };
  }),
  
  setActiveScenarioId: (id) => set({ activeScenarioId: id }),
  
  // Convenience actions for the active scenario
  setInitialState: (initialState) => set((state) => {
    const activeScenario = state.scenarios[state.activeScenarioId];
    if (!activeScenario) return state;
    
    return {
      scenarios: {
        ...state.scenarios,
        [state.activeScenarioId]: {
          ...activeScenario,
          initialState: initialState,
          lastModified: new Date()
        }
      }
    };
  }),

  setEventLedger: (ledger) => set((state) => {
    const activeScenario = state.scenarios[state.activeScenarioId];
    if (!activeScenario) return state;
    
    return {
      scenarios: {
        ...state.scenarios,
        [state.activeScenarioId]: {
          ...activeScenario,
          eventLedger: ledger,
          lastModified: new Date()
        }
      }
    };
  }),


  setEnhancedGoals: (goals) => set((state) => {
    const activeScenario = state.scenarios[state.activeScenarioId];
    if (!activeScenario) return state;

    return {
      scenarios: {
        ...state.scenarios,
        [state.activeScenarioId]: {
          ...activeScenario,
          enhancedGoals: goals,
          lastModified: new Date()
        }
      }
    };
  }),

  setPolicySettings: (settings) => set((state) => {
    const activeScenario = state.scenarios[state.activeScenarioId];
    if (!activeScenario) return state;

    const newSettings = typeof settings === 'function'
      ? settings(activeScenario.policySettings)
      : settings;

    return {
      scenarios: {
        ...state.scenarios,
        [state.activeScenarioId]: {
          ...activeScenario,
          policySettings: newSettings,
          lastModified: new Date()
        }
      }
    };
  }),

  updateActiveScenario: (update) => set((state) => {
    const activeScenario = state.scenarios[state.activeScenarioId];
    if (!activeScenario) return state;
    
    return {
      scenarios: {
        ...state.scenarios,
        [state.activeScenarioId]: {
          ...activeScenario,
          ...update,
          lastModified: new Date()
        }
      }
    };
  }),
  
  // Scenario management actions
  duplicateScenario: (scenarioId, newName) => {
    const state = get();
    const sourceScenario = state.scenarios[scenarioId];
    if (!sourceScenario) return scenarioId;
    
    const newId = generateId();
    const name = newName || `${sourceScenario.name} (Copy)`;
    const now = new Date();
    
    const newScenario: Scenario = {
      id: newId,
      name,
      description: sourceScenario.description,
      createdAt: now,
      lastModified: now,
      sourcePersona: sourceScenario.sourcePersona,
      initialState: { ...sourceScenario.initialState, id: generateId() }, // Copy initial state with new ID
      eventLedger: [...sourceScenario.eventLedger], // Deep copy the event ledger
      enhancedGoals: [...sourceScenario.enhancedGoals], // Deep copy enhanced goals
      policySettings: { ...sourceScenario.policySettings } // Copy policy settings
    };
    
    set((state) => ({
      scenarios: {
        ...state.scenarios,
        [newId]: newScenario
      },
      activeScenarioId: newId
    }));
    
    return newId;
  },
  
  deleteScenario: (scenarioId) => set((state) => {
    const scenarios = { ...state.scenarios };
    delete scenarios[scenarioId];
    
    // Ensure we always have at least one scenario
    const remainingIds = Object.keys(scenarios);
    if (remainingIds.length === 0) {
      const defaultId = generateId();
      const now = new Date();
      const defaultInitialState = createDefaultInitialState();
      scenarios[defaultId] = {
        id: defaultId,
        name: 'Base Plan',
        description: 'Default financial planning scenario',
        createdAt: now,
        lastModified: now,
        initialState: defaultInitialState,
        eventLedger: [defaultInitialState as any], // INITIAL_STATE must always be first event
        enhancedGoals: [],
        policySettings: createDefaultPolicySettings()
      };
      return {
        scenarios,
        activeScenarioId: defaultId
      };
    }
    
    // If we deleted the active scenario, switch to the first remaining one
    const newActiveId = state.activeScenarioId === scenarioId 
      ? remainingIds[0] 
      : state.activeScenarioId;
    
    return {
      scenarios,
      activeScenarioId: newActiveId
    };
  }),
  
  renameScenario: (scenarioId, newName) => set((state) => {
    const scenario = state.scenarios[scenarioId];
    if (!scenario) return state;
    
    return {
      scenarios: {
        ...state.scenarios,
        [scenarioId]: {
          ...scenario,
          name: newName,
          lastModified: new Date()
        }
      }
    };
  }),
  
  createPersonaScenario: (personaTitle, scenarioData) => {
    const state = get();
    const smartName = generatePersonaScenarioName(personaTitle, state.scenarios);
    const newId = generateId();
    const now = new Date();
    
    const newScenario: Scenario = {
      id: newId,
      name: smartName,
      createdAt: now,
      lastModified: now,
      sourcePersona: personaTitle.toLowerCase().replace(/\s+/g, '-'),
      ...scenarioData
    };
    
    set((state) => ({
      scenarios: {
        ...state.scenarios,
        [newId]: newScenario
      },
      activeScenarioId: newId
    }));
    
    return newId;
  },
  
  // Computed getters
  getActiveScenario: () => {
    const state = get();
    return state.scenarios[state.activeScenarioId];
  },
  
  getEventLedger: () => {
    const state = get();
    const activeScenario = state.scenarios[state.activeScenarioId];
    return activeScenario?.eventLedger || [];
  },

  getEnhancedGoals: () => {
    const state = get();
    const activeScenario = state.scenarios[state.activeScenarioId];
    return activeScenario?.enhancedGoals || [];
  },

  getPolicySettings: () => {
    const state = get();
    const activeScenario = state.scenarios[state.activeScenarioId];
    return activeScenario?.policySettings || createDefaultPolicySettings();
  },

  };
};