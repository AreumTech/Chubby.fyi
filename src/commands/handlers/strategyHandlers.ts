/**
 * Strategy Command Handlers
 * 
 * Handles strategy execution, plan creation, and strategy management commands.
 */

import { useAppStore } from '@/store/appStore';
import { strategyEngineService } from '@/services/strategies';
import { Scenario } from '@/store/slices/planSlice';
import { logger } from '@/utils/logger';
import { CommandHandler } from '../commandBus';
import { createDefaultPolicySettings } from '@/types/strategies/unified';
import type {
  ExecuteStrategyCommand,
  RemoveStrategyCommand,
  GetApplicableStrategiesCommand,
  GetStrategyParametersCommand,
  ValidateStrategyInputsCommand
} from '../types';

/**
 * Executes a financial strategy and generates events
 */
const executeStrategyHandler: CommandHandler<ExecuteStrategyCommand> = async (command) => {
  const { strategyId, context, basePlanId } = command.payload;
  const state = useAppStore.getState();
  
  try {
    logger.info(`[executeStrategyHandler] Executing strategy: ${strategyId}`);
    
    // Get current scenario data
    const activeScenario = state.getActiveScenario();
    if (!activeScenario) {
      throw new Error('No active scenario found');
    }
    
    // Execute the strategy using provided context
    const result = await strategyEngineService.executeStrategy(strategyId, context);
    
    if (!result.success) {
      throw new Error(`Strategy execution failed: ${result.warnings.join(', ')}`);
    }
    
    // Create a new plan with the strategy results
    const strategy = strategyEngineService.getStrategy(strategyId);
    if (!strategy) {
      throw new Error(`Strategy not found: ${strategyId}`);
    }
    
    const planResult = await strategyEngineService.createStrategyPlan(
      basePlanId,
      strategy,
      context,
      result
    );
    
    // Create strategy metadata with policy for sidebar display
    const strategyMetadata = {
      strategyId: strategy.id,
      strategyName: strategy.name,
      appliedAt: new Date(),
      configuration: context.userInputs,
      policy: result.policy
        ? {
            summary: result.policy.summary,
            details: result.policy.details
          }
        : {
            summary: `${strategy.name} applied`,
            details: []
          },
      eventIds: result.generatedEvents.map(e => e.event.id)
    };

    // Merge with existing active strategies (replace if same strategyId)
    const existingStrategies = activeScenario.activeStrategies || [];
    const activeStrategies = [
      ...existingStrategies.filter(s => s.strategyId !== strategy.id),
      strategyMetadata
    ];

    // Create new scenario with the generated events
    const newScenario: Scenario = {
      id: planResult.newPlanId,
      name: planResult.planName,
      description: `Generated by ${strategy.name} strategy`,
      eventLedger: planResult.events,
      enhancedGoals: [...(activeScenario.enhancedGoals || [])],
      initialState: activeScenario.initialState,
      createdAt: new Date(),
      lastModified: new Date(),
      sourcePersona: undefined,
      policySettings: activeScenario.policySettings || createDefaultPolicySettings(),
      activeStrategies // Store active strategies with policy
    };
    
    // Add the new scenario to the store
    const scenarios = { ...state.scenarios, [planResult.newPlanId]: newScenario };
    state.setScenarios(scenarios);
    state.setActiveScenarioId(planResult.newPlanId);

    logger.info(`[executeStrategyHandler] Successfully created strategy plan: ${planResult.planName}`);

    // Trigger simulation to process the new events
    const { createCommand } = await import('../types');
    const { CommandBus } = await import('../commandBus');

    const runSimCmd = createCommand.runSimulation();
    runSimCmd.meta = {
      source: 'executeStrategyHandler',
      correlationId: command.meta?.correlationId
    };

    await CommandBus.getInstance().dispatch(runSimCmd);
    logger.info(`[executeStrategyHandler] Simulation triggered for new strategy plan`);

  } catch (error) {
    logger.error(`[executeStrategyHandler] Failed to execute strategy ${strategyId}:`, error);
    throw error;
  }
};

/**
 * Removes a strategy and all its associated events
 */
const removeStrategyHandler: CommandHandler<RemoveStrategyCommand> = async (command) => {
  const { strategyId } = command.payload;
  const state = useAppStore.getState();

  try {
    logger.info(`[removeStrategyHandler] Removing strategy: ${strategyId}`);

    // Get current scenario
    const activeScenario = state.getActiveScenario();
    if (!activeScenario) {
      throw new Error('No active scenario found');
    }

    // Remove all events associated with this strategy
    const filteredEvents = activeScenario.eventLedger.filter(
      event => (event.metadata as any)?.strategyId !== strategyId
    );

    // Remove strategy from activeStrategies list
    const filteredStrategies = activeScenario.activeStrategies?.filter(
      s => s.strategyId !== strategyId
    ) || [];

    // Create new scenario with filtered events and strategies
    const newScenario: Scenario = {
      ...activeScenario,
      eventLedger: filteredEvents,
      activeStrategies: filteredStrategies,
      lastModified: new Date()
    };

    // Update the store
    const scenarios = { ...state.scenarios, [activeScenario.id]: newScenario };
    state.setScenarios(scenarios);

    logger.info(`[removeStrategyHandler] Successfully removed strategy: ${strategyId}`);

    // Trigger simulation to recalculate without the strategy
    const { createCommand } = await import('../types');
    const { CommandBus } = await import('../commandBus');

    const runSimCmd = createCommand.runSimulation();
    runSimCmd.meta = {
      source: 'removeStrategyHandler',
      correlationId: command.meta?.correlationId
    };

    await CommandBus.getInstance().dispatch(runSimCmd);
    logger.info(`[removeStrategyHandler] Simulation triggered after strategy removal`);

  } catch (error) {
    logger.error(`[removeStrategyHandler] Failed to remove strategy ${strategyId}:`, error);
    throw error;
  }
};

/**
 * Gets strategies applicable to the current financial situation
 */
const getApplicableStrategiesHandler: CommandHandler<GetApplicableStrategiesCommand> = async (command) => {
  const { context } = command.payload;
  const _state = useAppStore.getState();
  
  try {
    logger.info('[getApplicableStrategiesHandler] Getting applicable strategies');
    
    // Get applicable strategies using the provided context
    const applicableStrategies = strategyEngineService.getApplicableStrategies(context);
    const allStrategies = strategyEngineService.getAllStrategies();
    
    const applicableResult = applicableStrategies.map(strategy => ({
      id: strategy.id,
      name: strategy.name,
      category: strategy.category,
      description: strategy.config.description,
      priority: strategy.config.priority,
      estimatedTimeframe: strategy.config.estimatedTimeframe,
      difficultyLevel: strategy.config.difficultyLevel,
      tags: strategy.config.tags,
      applicable: true,
      reasons: strategy.canApply(context).reasons
    }));
    
    const allResult = allStrategies.map(strategy => {
      const _applicable = applicableStrategies.includes(strategy);
      const canApplyResult = strategy.canApply(context);
      
      return {
        id: strategy.id,
        name: strategy.name,
        category: strategy.category,
        description: strategy.config.description,
        priority: strategy.config.priority,
        estimatedTimeframe: strategy.config.estimatedTimeframe,
        difficultyLevel: strategy.config.difficultyLevel,
        tags: strategy.config.tags,
        applicable: canApplyResult.applicable,
        reasons: canApplyResult.reasons
      };
    });
    
    logger.info(`[getApplicableStrategiesHandler] Found ${applicableResult.length} applicable strategies`);
    
    return {
      applicable: applicableResult,
      all: allResult
    };
    
  } catch (error) {
    logger.error('[getApplicableStrategiesHandler] Failed to get strategies:', error);
    throw error;
  }
};

/**
 * Gets parameters required for a specific strategy
 */
const getStrategyParametersHandler: CommandHandler<GetStrategyParametersCommand> = async (command) => {
  const { strategyId } = command.payload;
  
  try {
    logger.info(`[getStrategyParametersHandler] Getting parameters for strategy: ${strategyId}`);
    
    const strategy = strategyEngineService.getStrategy(strategyId);
    if (!strategy) {
      throw new Error(`Strategy not found: ${strategyId}`);
    }
    
    const parameters = strategy.config.parameters || {};
    
    return {
      strategyId,
      parameters,
      config: strategy.config
    };
    
  } catch (error) {
    logger.error(`[getStrategyParametersHandler] Failed to get parameters for ${strategyId}:`, error);
    throw error;
  }
};

/**
 * Validates strategy inputs
 */
const validateStrategyInputsHandler: CommandHandler<ValidateStrategyInputsCommand> = async (command) => {
  const { strategyId, inputs } = command.payload;
  
  try {
    logger.info(`[validateStrategyInputsHandler] Validating inputs for strategy: ${strategyId}`);
    
    const validation = strategyEngineService.validateStrategyInputs(strategyId, inputs);
    
    return {
      strategyId,
      validation
    };
    
  } catch (error) {
    logger.error(`[validateStrategyInputsHandler] Failed to validate inputs for ${strategyId}:`, error);
    throw error;
  }
};

// Export handlers
export {
  executeStrategyHandler,
  removeStrategyHandler,
  getApplicableStrategiesHandler,
  getStrategyParametersHandler,
  validateStrategyInputsHandler
};