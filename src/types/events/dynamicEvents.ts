/**
 * Dynamic Financial Events System
 * 
 * Provides sophisticated, condition-based events that can adapt their behavior
 * based on the current financial state, enabling powerful strategy automation.
 * 
 * Key Features:
 * - Conditional execution based on cash levels, income, goals, etc.
 * - Mathematical calculations for smart allocations
 * - Support for all documented strategy patterns
 */

import { BaseEvent, EventType, EventPriority } from './base';
import { StandardAccountType } from '../accountTypes';

// ================================
// Core Dynamic Event System
// ================================

/**
 * Base interface for all dynamic events
 */
export interface DynamicFinancialEvent extends BaseEvent {
  isDynamic: true;
  
  /** How often to evaluate this event's conditions */
  evaluationFrequency: 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY' | 'ON_TRIGGER';
  
  /** Conditions that must be met for this event to execute */
  conditions?: ConditionSet;
  
  /** What to do if conditions aren't met */
  fallbackBehavior?: FallbackAction;
  
  /** Strategy context (if generated by a strategy) */
  strategyContext?: {
    strategyId: string;
    generatedBy: string;
    canUserEdit: boolean;
  };
}

/**
 * Simulation context passed to dynamic event evaluation
 */
export interface SimulationContext {
  currentMonth: number;
  currentAge: number;
  currentYear?: number;
  
  // Financial state
  cashBalance: number;
  accountBalances?: Record<StandardAccountType, number>;
  monthlyIncome: number;
  monthlyExpenses?: number;
  totalNetWorth: number;
  totalDebt?: number;
  
  // Individual account balances (backward compatibility)
  taxableBalance: number;
  taxDeferredBalance: number;
  rothBalance: number;
  hsaBalance: number;
  the529Balance: number;
  
  // Goal progress
  goalProgress?: Array<{
    goalId: string;
    currentAmount: number;
    targetAmount: number;
    progressPercentage: number;
    onTrack: boolean;
  }>;
  
  // Historical data for calculations
  lastMonthIncome?: number;
  yearToDateIncome?: number;
  averageIncomeLast6Months?: number;
}

// ================================
// Condition System
// ================================

export interface ConditionSet {
  /** Cash balance requirements */
  cashBalance?: BalanceCondition;
  
  /** Total income requirements */
  income?: IncomeCondition;
  
  /** Age-based conditions */
  age?: AgeCondition;
  
  /** Net worth requirements */
  netWorth?: BalanceCondition;
  
  /** Debt level conditions */
  debt?: DebtCondition;
  
  /** Goal progress requirements */
  goalProgress?: GoalProgressCondition;
  
  /** Account balance requirements */
  accountBalance?: AccountBalanceCondition;
  
  /** Time-based conditions */
  dateRange?: DateRangeCondition;
  
  /** Market conditions (future enhancement) */
  marketConditions?: MarketCondition;
}

export interface BalanceCondition {
  min?: number;
  max?: number;
  percentage?: {
    of: 'INCOME' | 'EXPENSES' | 'NET_WORTH';
    value: number;
  };
}

export interface IncomeCondition {
  minMonthly?: number;
  maxMonthly?: number;
  minAnnual?: number;
  maxAnnual?: number;
  changeThreshold?: {
    percentage: number;
    comparisonPeriod: 'LAST_MONTH' | 'LAST_3_MONTHS' | 'LAST_6_MONTHS' | 'LAST_YEAR';
  };
}

export interface AgeCondition {
  min?: number;
  max?: number;
}

export interface DebtCondition {
  maxTotal?: number;
  maxDebtToIncomeRatio?: number;
  specificDebts?: string[]; // IDs of specific debt events
}

export interface GoalProgressCondition {
  goalId: string;
  minProgress?: number; // Percentage (0-100)
  maxProgress?: number;
  onTrack?: boolean;
}

export interface AccountBalanceCondition {
  accountType: StandardAccountType;
  condition: BalanceCondition;
}

export interface DateRangeCondition {
  startMonth?: number;
  endMonth?: number;
  months?: number[]; // Specific months to execute
  years?: number[]; // Specific years to execute
}

export interface MarketCondition {
  portfolioDrawdown?: number; // Percentage drawdown from peak
  volatilityThreshold?: number;
  // Future: market sentiment indicators
}

// ================================
// Action System
// ================================

export type FallbackAction = 
  | 'SKIP' 
  | 'REDUCE_AMOUNT' 
  | 'DEFER_TO_NEXT_PERIOD'
  | 'USE_ALTERNATIVE_SOURCE'
  | 'NOTIFY_USER';

export interface EventAction {
  type: 'CONTRIBUTION' | 'TRANSFER' | 'WITHDRAWAL' | 'REBALANCE' | 'PAYMENT' | 'DEBT_PAYMENT';
  amount: number;
  sourceAccount?: StandardAccountType | 'cash' | 'debt';
  targetAccount?: StandardAccountType | 'cash' | 'debt';
  description: string;
  priority: EventPriority;
  metadata?: Record<string, any>; // Additional context-specific data
}

// ================================
// Specific Dynamic Event Types
// ================================

/**
 * CONDITIONAL_CONTRIBUTION: Invest X after keeping Y in cash
 * Use case: "Invest $2000/month, but only after keeping $50k in cash"
 */
export interface ConditionalContributionEvent extends DynamicFinancialEvent {
  type: EventType.CONDITIONAL_CONTRIBUTION;
  
  /** Target contribution amount */
  targetAmount: number;
  
  /** Where to invest the money */
  targetAccountType: StandardAccountType;
  
  /** Cash threshold to maintain */
  cashThreshold: number;
  
  /** How to calculate amount when conditions are met */
  contributionStrategy: {
    type: 'FIXED_AMOUNT' | 'PERCENTAGE_OF_EXCESS' | 'ALL_EXCESS';
    percentage?: number; // For PERCENTAGE_OF_EXCESS
  };
}

/**
 * WATERFALL_ALLOCATION: Priority-based savings cascade
 * Use case: "First max 401k match, then HSA, then Roth IRA, then taxable"
 */
export interface WaterfallAllocationEvent extends DynamicFinancialEvent {
  type: EventType.WATERFALL_ALLOCATION;
  
  /** Total amount to allocate per period */
  totalAmount: number;
  
  /** Allocation priorities (processed in order) */
  waterfall: Array<{
    priority: number;
    targetAccount: StandardAccountType;
    maxAmount?: number; // Annual limit (e.g., 401k limit)
    description: string;
    
    /** Conditions for this tier */
    conditions?: {
      employerMatch?: boolean; // Only if employer matching available
      incomeLimit?: number; // Income eligibility limits
      accountExists?: boolean; // Only if account is available
    };
  }>;
  
  /** How to handle remaining amount after all priorities */
  remainder: {
    action: 'INVEST_TAXABLE' | 'KEEP_CASH' | 'DISTRIBUTE_EVENLY';
    targetAccount?: StandardAccountType;
  };
}

/**
 * PERCENTAGE_CONTRIBUTION: Save X% of income automatically
 * Use case: "Save 20% of gross income in 401k"
 */
export interface PercentageContributionEvent extends DynamicFinancialEvent {
  type: EventType.PERCENTAGE_CONTRIBUTION;
  
  /** Percentage of income to save (0-1) */
  savingsRate: number;
  
  /** What income to base calculation on */
  incomeSource: {
    includeTypes: string[]; // Event types to include
    excludeTypes?: string[]; // Event types to exclude
    useGross?: boolean; // Before or after taxes
  };
  
  /** Where to invest the money */
  targetAccountType: StandardAccountType;
  
  /** Optional limits */
  limits: {
    minMonthly?: number;
    maxMonthly?: number;
    maxAnnual?: number; // For 401k limits, etc.
  };
  
  /** How to adjust savings rate based on income changes */
  incomeAdjustment?: {
    enabled: boolean;
    thresholds: Array<{
      incomeChange: number; // Percentage change
      savingsRateAdjustment: number; // How much to adjust rate
    }>;
  };
}

/**
 * SMART_DEBT_PAYMENT: Intelligent debt elimination
 * Use case: "Pay extra $1000/month using debt avalanche method"
 */
export interface SmartDebtPaymentEvent extends DynamicFinancialEvent {
  type: EventType.SMART_DEBT_PAYMENT;
  
  /** Debt elimination strategy */
  strategy: 'AVALANCHE' | 'SNOWBALL' | 'HIGHEST_PAYMENT' | 'CUSTOM';
  
  /** Extra payment amount */
  extraPayment: {
    type: 'FIXED_AMOUNT' | 'PERCENTAGE_OF_INCOME' | 'SURPLUS_AFTER_EXPENSES';
    amount: number;
    percentage?: number; // For percentage-based
  };
  
  /** Which debts to target (empty = all debts) */
  targetDebts?: string[];
  
  /** Minimum cash to maintain while paying debt */
  emergencyFundTarget: number;
  
  /** What to do when debts are paid off */
  completionAction: {
    redirectTo: StandardAccountType;
    continueAmount: boolean; // Keep investing the payment amount
  };
}

/**
 * GOAL_DRIVEN_CONTRIBUTION: Adjust contributions based on goal progress
 * Use case: "Increase house down payment savings if behind target"
 */
export interface GoalDrivenContributionEvent extends DynamicFinancialEvent {
  type: EventType.GOAL_DRIVEN_CONTRIBUTION;
  
  /** Goal to track progress for */
  targetGoalId: string;
  
  /** Target account for contributions */
  targetAccountType: StandardAccountType;
  
  /** How to adjust contributions based on goal progress */
  adjustmentStrategy: {
    type: 'PROGRESS_BASED' | 'TIME_BASED' | 'DEFICIT_BASED' | 'MARKET_RESPONSIVE';
    baseContribution: number;
    minContribution: number;
    maxContribution: number;
    aggressiveness: 'CONSERVATIVE' | 'MODERATE' | 'AGGRESSIVE';
  };
  
  /** Contribution limits and constraints */
  limits?: {
    minContribution?: number;
    maxContribution?: number;
    maxAdjustmentPercentage?: number;
    baseAmount?: number;
  };
  
  /** Progress-based adjustment thresholds */
  progressThresholds?: Array<{
    progressPercentage: number;
    action: 'INCREASE_CONTRIBUTION' | 'MAINTAIN_CONTRIBUTION' | 'OPTIMIZE_CONTRIBUTION';
    adjustmentPercentage: number;
  }>;
}

/**
 * EMERGENCY_FUND_MAINTENANCE: Automatically maintain target emergency fund
 * Use case: "Keep 6 months expenses in cash, invest excess"
 */
export interface EmergencyFundMaintenanceEvent extends DynamicFinancialEvent {
  type: EventType.EMERGENCY_FUND_MAINTENANCE;
  
  /** Target emergency fund size in months of expenses */
  targetMonths: number;
  
  /** Where to keep emergency fund */
  emergencyFundAccount: StandardAccountType;
  
  /** Funding sources for top-ups */
  fundingSources: Array<'income' | 'surplus' | 'other_savings'>;
  
  /** Top-up limits and constraints */
  topUpLimits?: {
    maxMonthlyTopUp?: number;
    maxPercentageOfIncome?: number;
  };
  
  /** Rebalancing threshold (as percentage of target) */
  rebalancingThreshold?: number;
  
  /** What to do with excess funds above target */
  drainExcess?: {
    enabled: boolean;
    targetAccount: StandardAccountType;
    maxDrainPercentage: number;
  };
}

// ================================
// Advanced Dynamic Event Types
// ================================

/**
 * AUTOMATIC_REBALANCING: Portfolio rebalancing based on drift
 * Use case: "Rebalance portfolio monthly if any asset class drifts >5% from target"
 */
export interface AutomaticRebalancingEvent extends DynamicFinancialEvent {
  type: EventType.AUTOMATIC_REBALANCING;
  
  /** Target asset allocation */
  targetAllocation: {
    stocks: number;    // 0.0 - 1.0
    bonds: number;     // 0.0 - 1.0
    international: number; // 0.0 - 1.0
    realEstate?: number;   // 0.0 - 1.0
    commodities?: number;  // 0.0 - 1.0
    cash?: number;         // 0.0 - 1.0
  };
  
  /** Rebalancing triggers */
  rebalancingTriggers: {
    driftThreshold: number; // Percentage drift to trigger (e.g., 0.05 for 5%)
    timeBased?: 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY';
    minimumTradeAmount?: number; // Don't rebalance if trades <$X
  };
  
  /** Which accounts to include in rebalancing */
  accountScope: {
    includedAccounts: StandardAccountType[];
    treatAsOnePortfolio: boolean; // True = asset locate across accounts
  };
  
  /** Rebalancing constraints */
  constraints?: {
    maxTradesPerRebalance?: number;
    preferredTradingAccounts?: StandardAccountType[]; // Prefer these for tax efficiency
    avoidWashSales?: boolean;
    minimumCashReserve?: number;
  };
}

/**
 * INCOME_RESPONSIVE_SAVINGS: Adjust savings rate with income changes
 * Use case: "Increase 401k contribution by 1% for every $10k income increase"
 */
export interface IncomeResponsiveSavingsEvent extends DynamicFinancialEvent {
  type: EventType.INCOME_RESPONSIVE_SAVINGS;
  
  /** Base savings configuration */
  baseSavingsRate: number; // Starting savings rate (0.0 - 1.0)
  targetAccountType: StandardAccountType;
  
  /** Income response rules */
  incomeThresholds: Array<{
    incomeIncrease: number; // Dollar threshold for adjustment
    savingsRateAdjustment: number; // Rate adjustment (e.g., 0.01 for +1%)
    description: string;
  }>;
  
  /** Constraints */
  limits: {
    minSavingsRate: number; // Never go below this rate
    maxSavingsRate: number; // Never go above this rate
    smoothingPeriod?: number; // Months to average income changes
  };
  
  /** Income calculation settings */
  incomeCalculation: {
    useGrossIncome: boolean;
    includeBonus?: boolean;
    excludeOneTimeEvents?: boolean;
    rollingAveragePeriod?: number; // Months for income averaging
  };
}

/**
 * LIFECYCLE_ADJUSTMENT: Age-based asset allocation changes
 * Use case: "Reduce stock allocation by 1% per year after age 50"
 */
export interface LifecycleAdjustmentEvent extends DynamicFinancialEvent {
  type: EventType.LIFECYCLE_ADJUSTMENT;
  
  /** Lifecycle stages and their allocations */
  lifecycleStages: Array<{
    ageRange: { min: number; max: number };
    targetAllocation: {
      stocks: number;
      bonds: number;
      international?: number;
      cash?: number;
    };
    stageName: string;
    description: string;
  }>;
  
  /** Adjustment rules */
  adjustmentRules: {
    frequency: 'ANNUAL' | 'QUARTERLY' | 'ON_BIRTHDAY';
    glidePathFormula?: 'LINEAR' | 'CUSTOM';
    smoothTransitions: boolean; // Gradual vs sudden changes
  };
  
  /** Implementation settings */
  implementation: {
    accountScope: StandardAccountType[];
    rebalancingMethod: 'NEW_CONTRIBUTIONS' | 'FULL_REBALANCE' | 'HYBRID';
    driftThreshold?: number; // Only adjust if drift > threshold
  };
}

/**
 * TAX_LOSS_HARVESTING: Year-end tax optimization
 * Use case: "Harvest tax losses in December, avoid wash sales"
 */
export interface TaxLossHarvestingEvent extends DynamicFinancialEvent {
  type: EventType.TAX_LOSS_HARVESTING;
  
  /** Harvesting thresholds */
  thresholds: {
    minimumAccountValue: number; // Don't harvest if taxable account < $X
    minimumTaxSavings: number;   // Don't harvest if tax savings < $Y
    maxAnnualHarvesting?: number; // Maximum harvesting per year
  };
  
  /** Tax calculation settings */
  taxSettings: {
    marginalTaxRate?: number;     // User's marginal tax rate (0.0 - 0.5)
    capitalGainsRate?: number;    // Long-term capital gains rate
    stateRate?: number;           // State tax rate
  };
  
  /** Harvesting rules */
  harvestingRules: {
    timing: 'YEAR_END' | 'QUARTERLY' | 'CONTINUOUS';
    maintainAllocation: boolean;  // Try to maintain target allocation
    allowedAssetClasses: string[]; // Which asset classes to harvest
  };
  
  /** Wash sale protection */
  washSaleProtection: {
    enabled: boolean;
    useSubstitutes: boolean;      // Use substitute ETFs
    waitPeriod?: number;          // Days to wait before repurchasing
    substituteList?: Array<{
      original: string;
      substitute: string;
    }>;
  };
}

// ================================
// Utility Types
// ================================

/**
 * Union type of all dynamic event types
 */
export type AnyDynamicEvent = 
  | ConditionalContributionEvent
  | WaterfallAllocationEvent  
  | PercentageContributionEvent
  | SmartDebtPaymentEvent
  | GoalDrivenContributionEvent
  | EmergencyFundMaintenanceEvent
  | AutomaticRebalancingEvent
  | IncomeResponsiveSavingsEvent
  | LifecycleAdjustmentEvent
  | TaxLossHarvestingEvent;

/**
 * Helper type to extract dynamic event types
 */
export type DynamicEventType = AnyDynamicEvent['type'];

/**
 * Configuration for dynamic event evaluation
 */
export interface DynamicEventConfig {
  /** Enable debug logging */
  debugMode: boolean;
  
  /** Maximum number of actions per evaluation */
  maxActionsPerEvaluation: number;
  
  /** Default fallback behavior */
  defaultFallback: FallbackAction;
  
  /** Performance thresholds */
  performance: {
    maxEvaluationTimeMs: number;
    maxMemoryUsageMB: number;
  };
}

// ================================
// Evaluation Engine Interface
// ================================

/**
 * Interface for the dynamic event evaluation engine
 */
export interface DynamicEventEvaluator {
  /**
   * Evaluate a dynamic event and return actions to execute
   */
  evaluate(
    event: AnyDynamicEvent, 
    context: SimulationContext, 
    config: DynamicEventConfig
  ): Promise<EventAction[]>;
  
  /**
   * Check if event conditions are met
   */
  checkConditions(
    conditions: ConditionSet, 
    context: SimulationContext
  ): boolean;
  
  /**
   * Calculate derived values for event execution
   */
  calculateAmounts(
    event: AnyDynamicEvent, 
    context: SimulationContext
  ): Record<string, number>;
}